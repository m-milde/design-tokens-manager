<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>DTMC - Design Tokens Map Creator (v3.0 - Interactive Sidebar)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
        }

        .dtmc-container {
            display: flex;
            height: 100vh;
        }

        .dtmc-sidebar {
            width: 320px;
            background: #1e293b;
            border-right: 1px solid #334155;
            padding: 20px;
            overflow-y: auto;
        }

        .dtmc-sidebar h2 {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .dtmc-token-types {
            margin-bottom: 32px;
        }

        .dtmc-type-btn {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: #334155;
            border: 1px solid #475569;
            border-radius: 8px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 14px;
        }

        .dtmc-type-btn:hover {
            background: #475569;
            border-color: #64748b;
        }

        .dtmc-type-btn.active {
            background: #3b82f6;
            border-color: #60a5fa;
            color: white;
        }

        .dtmc-layer-section {
            margin-bottom: 24px;
        }

        .dtmc-layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .dtmc-layer-title {
            font-size: 13px;
            font-weight: 500;
            color: #cbd5e1;
        }

        .dtmc-add-btn {
            background: #059669;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .dtmc-add-btn:hover {
            background: #047857;
        }

        .dtmc-token-item {
            background: #334155;
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
            font-size: 13px;
        }

        .dtmc-token-item:hover {
            background: #475569;
            border-color: #64748b;
        }

        .dtmc-token-item:active {
            cursor: grabbing;
        }

        .dtmc-token-name {
            font-weight: 500;
            color: #e2e8f0;
            margin-bottom: 4px;
        }

        .dtmc-token-value {
            color: #94a3b8;
            font-size: 12px;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .dtmc-main {
            flex: 1;
            position: relative;
        }

        .dtmc-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .dtmc-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .dtmc-btn.primary {
            background: #3b82f6;
            color: white;
        }

        .dtmc-btn.primary:hover {
            background: #2563eb;
        }

        .dtmc-btn.danger {
            background: #ef4444;
            color: white;
        }

        .dtmc-btn.danger:hover {
            background: #dc2626;
        }

        .dtmc-btn.warning {
            background: #f59e0b;
            color: white;
        }

        .dtmc-btn.warning:hover {
            background: #d97706;
        }

        #dtmc-canvas {
            width: 100%;
            height: 100%;
            background: #0f172a;
            cursor: grab;
        }

        #dtmc-canvas:active {
            cursor: grabbing;
        }

        .dtmc-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }

        .dtmc-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
        }

        .dtmc-modal h3 {
            margin-bottom: 20px;
            color: #e2e8f0;
        }

        .dtmc-form-group {
            margin-bottom: 16px;
        }

        .dtmc-form-group label {
            display: block;
            margin-bottom: 6px;
            color: #cbd5e1;
            font-size: 14px;
        }

        .dtmc-form-group input {
            width: 100%;
            padding: 10px 12px;
            background: #334155;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 14px;
        }

        .dtmc-form-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .dtmc-modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        /* Context Menu Styles */
        .dtmc-context-menu {
            position: fixed;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            padding: 8px 0;
            z-index: 1000;
            display: none;
            min-width: 160px;
        }

        .dtmc-context-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            color: #e2e8f0;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .dtmc-context-menu-item:hover {
            background: #334155;
        }

        .dtmc-context-icon {
            font-size: 16px;
        }

        .dtmc-btn.secondary {
            background: #64748b;
            color: white;
        }

        .dtmc-btn.secondary:hover {
            background: #475569;
        }

        .dtmc-drag-preview {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            background: #334155;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="dtmc-container">
        <!-- Sidebar -->
        <div class="dtmc-sidebar">
            <h2>Token Types</h2>
            <div class="dtmc-token-types">
                <button class="dtmc-type-btn active" data-type="color">Color</button>
                <button class="dtmc-type-btn" data-type="string">String</button>
                <button class="dtmc-type-btn" data-type="number">Number</button>
                <button class="dtmc-type-btn" data-type="boolean">Boolean</button>
                <button class="dtmc-type-btn" data-type="spacing">Spacing</button>
                <button class="dtmc-type-btn" data-type="text">Text</button>
            </div>

            <h2>Token Layers</h2>
            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Primitive</span>
                    <button class="dtmc-add-btn" data-layer="primitive">+ Add</button>
                </div>
                <div id="primitive-tokens" class="dtmc-tokens-list"></div>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Base</span>
                    <button class="dtmc-add-btn" data-layer="base">+ Add</button>
                </div>
                <div id="base-tokens" class="dtmc-tokens-list"></div>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Semantic</span>
                    <button class="dtmc-add-btn" data-layer="semantic">+ Add</button>
                </div>
                <div id="semantic-tokens" class="dtmc-tokens-list"></div>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Specific</span>
                    <button class="dtmc-add-btn" data-layer="specific">+ Add</button>
                </div>
                <div id="specific-tokens" class="dtmc-tokens-list"></div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="dtmc-main">
            <div class="dtmc-controls">
                <button id="dtmc-undo-btn" class="dtmc-btn warning">Undo</button>
                <button id="dtmc-clear-btn" class="dtmc-btn danger">Clear All</button>
                <button id="dtmc-export-btn" class="dtmc-btn primary">Export JSON</button>
            </div>
            <canvas id="dtmc-canvas"></canvas>
        </div>
    </div>

    <!-- Token Creation Modal -->
    <div id="dtmc-token-modal" class="dtmc-modal">
        <div class="dtmc-modal-content">
            <h3>Create New Token</h3>
            <div class="dtmc-form-group">
                <label for="token-name">Token Name</label>
                <input type="text" id="token-name" placeholder="e.g., primary-blue">
            </div>
            <div class="dtmc-form-group">
                <label for="token-value">Token Value</label>
                <input type="text" id="token-value" placeholder="e.g., #4a90e2">
            </div>
            <div class="dtmc-modal-buttons">
                <button id="dtmc-cancel-btn" class="dtmc-btn secondary">Cancel</button>
                <button id="dtmc-create-btn" class="dtmc-btn primary">Create Token</button>
            </div>
        </div>
    </div>

    <!-- Context menu for nodes -->
    <div id="dtmc-context-menu" class="dtmc-context-menu">
        <div class="dtmc-context-menu-item" id="dtmc-delete-node">
            <span class="dtmc-context-icon">🗑️</span>
            Delete Node
        </div>
    </div>

    <!-- Drag Preview -->
    <div id="dtmc-drag-preview" class="dtmc-drag-preview" style="display: none;"></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('dtmc-canvas');
        const ctx = canvas.getContext('2d');
        
        // Constants
        const SOCKET_RADIUS = 12;
        const NODE_WIDTH = 200;
        const NODE_HEIGHT = 120;
        
        // State
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let isDragging = false;
        let isPanning = false;
        let panOffset = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let isConnecting = false;
        let connectionStart = null;
        let startSocket = null;
        let endSocket = null;
        let selectedTokenType = 'color';
        let selectedLayer = null;
        let tokens = {
            primitive: [],
            base: [],
            semantic: [],
            specific: []
        };
        let undoStack = [];
        let dragPreview = null;
        let draggedToken = null;

        // Initialize
        function init() {
            console.log('🎯 DTMC Interactive Sidebar System Loaded!');
            console.log('Features: Token Types, Layers, Drag & Drop, Modal Creation');
            
            setupEventListeners();
            setupSidebar();
            loadSampleTokens();
            resizeCanvas();
            render();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Canvas events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Control buttons
            document.getElementById('dtmc-clear-btn').addEventListener('click', clearAll);
            document.getElementById('dtmc-undo-btn').addEventListener('click', undo);
            document.getElementById('dtmc-export-btn').addEventListener('click', exportJSON);
            
            // Modal events
            document.getElementById('dtmc-cancel-btn').addEventListener('click', closeModal);
            document.getElementById('dtmc-create-btn').addEventListener('click', createToken);
            
            // Context menu events
            document.getElementById('dtmc-delete-node').addEventListener('click', () => {
                const contextMenu = document.getElementById('dtmc-context-menu');
                const nodeId = contextMenu.dataset.nodeId;
                if (nodeId) {
                    deleteNode(nodeId);
                    hideContextMenu();
                }
            });
            
            // Window events
            window.addEventListener('resize', resizeCanvas);
            
            // Prevent context menu on right click
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // Setup sidebar functionality
        function setupSidebar() {
            // Token type selection
            document.querySelectorAll('.dtmc-type-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.dtmc-type-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedTokenType = btn.dataset.type;
                    console.log('Selected token type:', selectedTokenType);
                });
            });

            // Add token buttons
            document.querySelectorAll('.dtmc-add-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedLayer = btn.dataset.layer;
                    openModal();
                });
            });
        }

        // Load sample tokens
        function loadSampleTokens() {
            tokens.primitive = [
                { name: 'primary-blue', value: '#4a90e2', type: 'color' },
                { name: 'secondary-purple', value: '#805ad5', type: 'color' },
                { name: 'font-size-base', value: '16px', type: 'number' }
            ];
            
            tokens.base = [
                { name: 'color-brand', value: '{primitive.primary-blue}', type: 'color' }
            ];
            
            tokens.semantic = [
                { name: 'button-bg', value: '{base.color-brand}', type: 'color' }
            ];
            
            tokens.specific = [];
            
            renderSidebar();
        }

        // Render sidebar
        function renderSidebar() {
            Object.keys(tokens).forEach(layer => {
                const container = document.getElementById(`${layer}-tokens`);
                container.innerHTML = '';
                
                tokens[layer].forEach(token => {
                    const tokenElement = createTokenElement(token, layer);
                    container.appendChild(tokenElement);
                });
            });
        }

        // Create token element for sidebar
        function createTokenElement(token, layer) {
            const div = document.createElement('div');
            div.className = 'dtmc-token-item';
            div.draggable = true;
            div.dataset.tokenName = token.name;
            div.dataset.tokenValue = token.value;
            div.dataset.tokenType = token.type;
            div.dataset.layer = layer;
            
            div.innerHTML = `
                <div class="dtmc-token-name">${token.name}</div>
                <div class="dtmc-token-value">${token.value}</div>
            `;
            
            // Drag events
            div.addEventListener('dragstart', (e) => handleDragStart(e, token, layer));
            div.addEventListener('dragend', handleDragEnd);
            
            return div;
        }

        // Handle drag start
        function handleDragStart(e, token, layer) {
            draggedToken = { ...token, layer };
            dragPreview = e.target.cloneNode(true);
            dragPreview.style.position = 'absolute';
            dragPreview.style.opacity = '0.8';
            dragPreview.style.pointerEvents = 'none';
            dragPreview.style.zIndex = '1000';
            document.body.appendChild(dragPreview);
            
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', JSON.stringify(draggedToken));
        }

        // Handle drag end
        function handleDragEnd() {
            if (dragPreview) {
                document.body.removeChild(dragPreview);
                dragPreview = null;
            }
            draggedToken = null;
        }

        // Open modal
        function openModal() {
            document.getElementById('dtmc-token-modal').style.display = 'block';
            document.getElementById('token-name').focus();
        }

        // Close modal
        function closeModal() {
            document.getElementById('dtmc-token-modal').style.display = 'none';
            document.getElementById('token-name').value = '';
            document.getElementById('token-value').value = '';
        }

        // Create token
        function createToken() {
            const name = document.getElementById('token-name').value.trim();
            const value = document.getElementById('token-value').value.trim();
            
            if (!name || !value) {
                alert('Please fill in both name and value');
                return;
            }
            
            const newToken = {
                name,
                value,
                type: selectedTokenType
            };
            
            tokens[selectedLayer].push(newToken);
            renderSidebar();
            closeModal();
            
            // Update any existing nodes with this token
            updateNodesWithToken(newToken);
            
            console.log(`Created ${selectedLayer} token:`, newToken);
        }

        // Populate reference dropdown with available tokens
        function populateReferenceDropdown() {
            const dropdown = document.getElementById('token-reference-dropdown');
            const countSpan = document.getElementById('available-tokens-count');
            
            // Clear existing options
            dropdown.innerHTML = '<option value="">Select from existing tokens...</option>';
            
            let availableTokens = [];
            
            // Collect tokens from all layers except the current one
            Object.keys(tokens).forEach(layer => {
                if (layer !== selectedLayer) {
                    tokens[layer].forEach(token => {
                        availableTokens.push({
                            layer: layer,
                            name: token.name,
                            value: token.value,
                            displayText: `${layer}.${token.name} (${token.value})`
                        });
                    });
                }
            });
            
            // Add options to dropdown
            availableTokens.forEach(token => {
                const option = document.createElement('option');
                option.value = JSON.stringify(token);
                option.textContent = token.displayText;
                dropdown.appendChild(option);
            });
            
            // Update count
            countSpan.textContent = `${availableTokens.length} tokens available`;
            
            // Add change event listener
            dropdown.onchange = function() {
                const selectedValue = this.value;
                if (selectedValue) {
                    const tokenData = JSON.parse(selectedValue);
                    document.getElementById('token-value-custom').value = `{${tokenData.layer}.${tokenData.name}}`;
                }
            };
        }

        // Setup color swatch click events
        function setupColorSwatchEvents() {
            const colorSwatches = document.querySelectorAll('.dtmc-color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', function() {
                    // Remove selected class from all swatches
                    colorSwatches.forEach(s => s.classList.remove('selected'));
                    // Add selected class to clicked swatch
                    this.classList.add('selected');
                    // Update the token value input
                    const colorValue = this.getAttribute('data-color');
                    document.getElementById('token-value').value = colorValue;
                });
            });
        }

        // Mouse event handlers
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / 1;
            const y = (e.clientY - rect.top - panOffset.y) / 1;
            
            // Check if clicking on a socket
            const socketInfo = getSocketAtPoint(x, y);
            if (socketInfo) {
                isConnecting = true;
                connectionStart = socketInfo.node;
                startSocket = socketInfo.socket;
                return;
            }
            
            // Check if clicking on a node
            const clickedNode = getNodeAtPoint(x, y);
            if (clickedNode) {
                // Right click or Ctrl+click for context menu
                if (e.button === 2 || (e.ctrlKey && e.button === 0)) {
                    e.preventDefault();
                    showNodeContextMenu(clickedNode, e.clientX, e.clientY);
                    return;
                }
                
                selectedNode = clickedNode;
                isDragging = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                return;
            }
            
            // Start panning
            isPanning = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
        }

        function handleMouseMove(e) {
            if (isConnecting) {
                // Handle connection preview
                render();
                drawConnectionPreview(e);
                return;
            }
            
            if (isDragging && selectedNode) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                selectedNode.x += deltaX;
                selectedNode.y += deltaY;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                render();
                return;
            }
            
            if (isPanning) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                panOffset.x += deltaX;
                panOffset.y += deltaY;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                render();
            }
        }

        function handleMouseUp(e) {
            if (isConnecting) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - panOffset.x) / 1;
                const y = (e.clientY - rect.top - panOffset.y) / 1;
                
                const socketInfo = getSocketAtPoint(x, y);
                if (socketInfo && socketInfo.node !== connectionStart) {
                    // Validate connection (output to input only)
                    if (startSocket === 'right' || startSocket === 'bottom') {
                        if (socketInfo.socket === 'top' || socketInfo.socket === 'left') {
                            // Store original value if not already stored
                            if (!socketInfo.node.originalValue) {
                                socketInfo.node.originalValue = socketInfo.node.value;
                                console.log(`Stored original value for ${socketInfo.node.name}: ${socketInfo.node.originalValue}`);
                            } else {
                                console.log(`Original value already stored for ${socketInfo.node.name}: ${socketInfo.node.originalValue}`);
                            }
                            
                            // Create connection
                            const connection = {
                                startNode: connectionStart,
                                endNode: socketInfo.node,
                                startSocket: startSocket,
                                endSocket: socketInfo.socket
                            };
                            
                            connections.push(connection);
                            
                            // Update the target node's value to show the reference path to the source
                            const referencePath = `{${connectionStart.layer}.${connectionStart.name}}`;
                            socketInfo.node.value = referencePath;
                            
                            // Also update the corresponding token in the tokens object for sidebar and JSON export
                            const targetLayer = socketInfo.node.layer;
                            const targetToken = tokens[targetLayer]?.find(t => t.name === socketInfo.node.name);
                            if (targetToken) {
                                targetToken.value = referencePath;
                                console.log(`Updated token ${targetLayer}.${socketInfo.node.name} to: ${referencePath}`);
                            }
                            
                            // Update sidebar to show updated values
                            renderSidebar();
                            
                            saveState();
                            
                            console.log(`Connected ${connectionStart.name} to ${socketInfo.node.name} with path: ${referencePath}`);
                        } else {
                            console.warn('Invalid connection: Can only connect output to input sockets');
                        }
                    } else {
                        console.warn('Invalid connection: Can only start from output sockets');
                    }
                }
                
                isConnecting = false;
                connectionStart = null;
                startSocket = null;
                render();
                return;
            }
            
            isDragging = false;
            isPanning = false;
            selectedNode = null;
        }

        function handleWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            // Implement zoom logic here if needed
        }

        // Helper functions
        function getNodeAtPoint(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (x >= node.x && x <= node.x + NODE_WIDTH &&
                    y >= node.y && y <= node.y + NODE_HEIGHT) {
                    return node;
                }
            }
            return null;
        }

        function getSocketAtPoint(x, y) {
            for (const node of nodes) {
                const sockets = [
                    { x: node.x + NODE_WIDTH / 2, y: node.y, type: 'input', socket: 'top' },
                    { x: node.x, y: node.y + NODE_HEIGHT / 2, type: 'input', socket: 'left' },
                    { x: node.x + NODE_WIDTH, y: node.y + NODE_HEIGHT / 2, type: 'output', socket: 'right' },
                    { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT, type: 'output', socket: 'bottom' }
                ];
                
                for (const socket of sockets) {
                    const distance = Math.sqrt((x - socket.x) ** 2 + (y - socket.y) ** 2);
                    if (distance <= SOCKET_RADIUS) {
                        return { node, ...socket };
                    }
                }
            }
            return null;
        }

        function drawConnectionPreview(e) {
            if (!connectionStart) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / 1;
            const y = (e.clientY - rect.top - panOffset.y) / 1;
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            const startPoint = getSocketPosition(connectionStart, startSocket);
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function getSocketPosition(node, socket) {
            switch (socket) {
                case 'top': return { x: node.x + NODE_WIDTH / 2, y: node.y };
                case 'left': return { x: node.x, y: node.y + NODE_HEIGHT / 2 };
                case 'right': return { x: node.x + NODE_WIDTH, y: node.y + NODE_HEIGHT / 2 };
                case 'bottom': return { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT };
                default: return { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT / 2 };
            }
        }

        // Context menu functions
        function showNodeContextMenu(node, x, y) {
            const contextMenu = document.getElementById('dtmc-context-menu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            
            // Store the node for deletion
            contextMenu.dataset.nodeId = node.id;
            
            // Add click outside to close
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu);
            }, 100);
        }

        function hideContextMenu() {
            const contextMenu = document.getElementById('dtmc-context-menu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideContextMenu);
        }

        function deleteNode(nodeId) {
            const nodeIndex = nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex === -1) return;
            
            const node = nodes[nodeIndex];
            
            console.log(`Deleting node: ${node.name} (ID: ${nodeId})`);
            console.log(`Node original value: ${node.originalValue}, current value: ${node.value}`);
            
            // Remove all connections involving this node
            const connectionsBefore = connections.length;
            connections = connections.filter(conn => 
                conn.startNode.id !== nodeId && conn.endNode.id !== nodeId
            );
            const connectionsAfter = connections.length;
            console.log(`Removed ${connectionsBefore - connectionsAfter} connections`);
            
            // Remove the node
            nodes.splice(nodeIndex, 1);
            
            // Restore original token value if it was modified by connections
            if (node.originalValue && node.originalValue !== node.value) {
                // Find the corresponding token and restore its value
                const tokenLayer = node.layer;
                const tokenIndex = tokens[tokenLayer]?.findIndex(t => t.name === node.name);
                if (tokenIndex !== -1) {
                    const oldValue = tokens[tokenLayer][tokenIndex].value;
                    tokens[tokenLayer][tokenIndex].value = node.originalValue;
                    console.log(`Restored token ${tokenLayer}.${node.name}: ${oldValue} → ${node.originalValue}`);
                } else {
                    console.warn(`Token not found in layer ${tokenLayer} for name ${node.name}`);
                }
            } else {
                console.log(`No value restoration needed for node ${node.name}`);
            }
            
            // Update sidebar
            renderSidebar();
            
            // Save state
            saveState();
            
            // Re-render
            render();
            
            console.log(`Successfully deleted node: ${node.name}`);
        }

        // Function to update node values when connections are made
        function updateNodeValues(node) {
            // This function will be called when connections are made
            // For now, it's a placeholder that can be expanded later
            console.log(`Updating values for node: ${node.name}`);
        }

        // Canvas drop handling
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / 1;
            const y = (e.clientY - rect.top - panOffset.y) / 1;
            
            // Create new node from token
            const newNode = {
                id: Date.now(),
                x: x - NODE_WIDTH / 2,
                y: y - NODE_HEIGHT / 2,
                name: draggedToken.name,
                value: draggedToken.value,
                type: draggedToken.type,
                layer: draggedToken.layer,
                originalValue: draggedToken.value // Store original value for restoration
            };
            
            nodes.push(newNode);
            saveState();
            render();
            
            console.log('Created node from token:', newNode);
        });

        // Rendering
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply pan offset
            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            
            // Draw connections
            connections.forEach(connection => {
                drawConnection(connection.startNode, connection.endNode, connection.startSocket, connection.endSocket);
            });
            
            // Draw nodes
            nodes.forEach(node => {
                drawNode(node);
            });
            
            ctx.restore();
        }

        function drawNode(node) {
            // Node background
            ctx.fillStyle = '#1e293b';
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.roundRect(node.x, node.y, NODE_WIDTH, NODE_HEIGHT, 12);
            ctx.fill();
            ctx.stroke();
            
            // Node content
            ctx.fillStyle = '#94a3b8';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            
            // Layer label
            ctx.fillStyle = '#64748b';
            ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(node.layer.toUpperCase(), node.x + NODE_WIDTH / 2, node.y + 20);
            
            // Token name
            ctx.fillStyle = '#e2e8f0';
            ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(node.name, node.x + NODE_WIDTH / 2, node.y + 45);
            
            // Token value
            ctx.fillStyle = '#94a3b8';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(node.value, node.x + NODE_WIDTH / 2, node.y + 70);
            
            // Draw sockets
            drawSockets(ctx, node);
        }

        function drawSockets(ctx, node) {
            // Top socket (INPUT - red)
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(node.x + NODE_WIDTH / 2, node.y, SOCKET_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Left socket (INPUT - red)
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(node.x, node.y + NODE_HEIGHT / 2, SOCKET_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Right socket (OUTPUT - green)
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.arc(node.x + NODE_WIDTH, node.y + NODE_HEIGHT / 2, SOCKET_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Bottom socket (OUTPUT - green)
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.arc(node.x + NODE_WIDTH / 2, node.y + NODE_HEIGHT, SOCKET_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        function drawConnection(startNode, endNode, startSocket, endSocket) {
            const startPoint = getSocketPosition(startNode, startSocket);
            const endPoint = getSocketPosition(endNode, endSocket);
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            
            // Create curved connection
            const controlPoint1 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: startPoint.y
            };
            const controlPoint2 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: endPoint.y
            };
            
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.bezierCurveTo(
                controlPoint1.x, controlPoint1.y,
                controlPoint2.x, controlPoint2.y,
                endPoint.x, endPoint.y
            );
            ctx.stroke();
        }

        // Utility functions
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            render();
        }

        function saveState() {
            undoStack.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections))
            });
            
            if (undoStack.length > 20) {
                undoStack.shift();
            }
        }

        function undo() {
            if (undoStack.length > 0) {
                const previousState = undoStack.pop();
                nodes = previousState.nodes;
                connections = previousState.connections;
                render();
            }
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all nodes and connections?')) {
                nodes = [];
                connections = [];
                undoStack = [];
                render();
            }
        }

        function exportJSON() {
            const data = {
                tokens: tokens,
                nodes: nodes,
                connections: connections
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dtmc-tokens.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Update nodes when tokens change
        function updateNodesWithToken(token) {
            nodes.forEach(node => {
                if (node.name === token.name && node.layer === selectedLayer) {
                    node.value = token.value;
                    console.log(`Updated existing node: ${node.name} with value: ${node.value}`);
                }
            });
            render();
        }

        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>
