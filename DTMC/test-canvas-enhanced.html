<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DTMC - Enhanced Design Tokens Map Creator</title>
    <link rel="stylesheet" href="dtmc-styles.css">
</head>
<body>
    <div class="dtmc-container">
        <div class="dtmc-sidebar">
            <h2>Design Tokens</h2>
            
            <div class="dtmc-token-types">
                <button class="dtmc-type-btn active" data-type="color">Color</button>
                <button class="dtmc-type-btn" data-type="spacing">Spacing</button>
                <button class="dtmc-type-btn" data-type="typography">Typography</button>
                <button class="dtmc-type-btn" data-type="number">Number</button>
                <button class="dtmc-type-btn" data-type="string">String</button>
                <button class="dtmc-type-btn" data-type="boolean">Boolean</button>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Primitive</span>
                    <button class="dtmc-add-btn" data-layer="primitive">+ Add</button>
                </div>
                <div class="dtmc-tokens-list" id="primitive-tokens"></div>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Base</span>
                    <button class="dtmc-add-btn" data-layer="base">+ Add</button>
                </div>
                <div class="dtmc-tokens-list" id="base-tokens"></div>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Semantic</span>
                    <button class="dtmc-add-btn" data-layer="semantic">+ Add</button>
                </div>
                <div class="dtmc-tokens-list" id="semantic-tokens"></div>
            </div>

            <div class="dtmc-layer-section">
                <div class="dtmc-layer-header">
                    <span class="dtmc-layer-title">Specific</span>
                    <button class="dtmc-add-btn" data-layer="specific">+ Add</button>
                </div>
                <div class="dtmc-tokens-list" id="specific-tokens"></div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="dtmc-main">
                    <div class="dtmc-controls">
            <button id="dtmc-undo-btn" class="dtmc-btn warning">Undo</button>
            <button id="dtmc-clear-btn" class="dtmc-btn danger">Clear All</button>
            <button id="dtmc-export-btn" class="dtmc-btn primary">Export JSON</button>
            <button id="dtmc-save-btn" class="dtmc-btn secondary">Save Session</button>
            <button id="dtmc-load-btn" class="dtmc-btn secondary">Load Session</button>
            <div class="dtmc-zoom-controls">
                <button id="dtmc-zoom-out-btn" class="dtmc-btn secondary">-</button>
                <span id="dtmc-zoom-level">100%</span>
                <button id="dtmc-zoom-in-btn" class="dtmc-btn secondary">+</button>
                <button id="dtmc-reset-zoom-btn" class="dtmc-btn secondary">Reset</button>
            </div>
        </div>
            <canvas id="dtmc-canvas"></canvas>
            
            <!-- Mini-map for navigation -->
            <div class="dtmc-minimap">
                <div class="dtmc-minimap-header">
                    <span>Mini-map</span>
                    <button id="dtmc-minimap-toggle" class="dtmc-btn secondary">Toggle</button>
                </div>
                <canvas id="dtmc-minimap-canvas" width="200" height="150"></canvas>
            </div>
        </div>
    </div>

    <!-- Enhanced Token Creation Modal -->
    <div id="dtmc-token-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Create New Token</h3>
                <p class="dtmc-modal-subtitle">Add a new token to your design system</p>
            </div>
            
            <!-- Token Name Input -->
            <div class="dtmc-form-group">
                <label for="token-name" class="dtmc-form-label">Token Name</label>
                <input type="text" id="token-name" class="dtmc-form-input" placeholder="e.g., primary-blue">
            </div>
            
            <!-- Dynamic Value Section -->
            <div id="token-value-section">
                <!-- Color Token Section -->
                <div id="color-token-section" class="dtmc-token-section">
                    <label class="dtmc-form-label">Choose a color:</label>
                    <div class="dtmc-color-palette">
                        <div class="dtmc-color-swatch" data-color="#ef4444" style="background-color: #ef4444;"></div>
                        <div class="dtmc-color-swatch" data-color="#22c55e" style="background-color: #22c55e;"></div>
                        <div class="dtmc-color-swatch" data-color="#3b82f6" style="background-color: #3b82f6;"></div>
                        <div class="dtmc-color-swatch" data-color="#f59e0b" style="background-color: #f59e0b;"></div>
                        <div class="dtmc-color-swatch" data-color="#8b5cf6" style="background-color: #8b5cf6;"></div>
                        <div class="dtmc-color-swatch" data-color="#06b6d4" style="background-color: #06b6d4;"></div>
                        <div class="dtmc-color-swatch" data-color="#84cc16" style="background-color: #84cc16;"></div>
                        <div class="dtmc-color-swatch" data-color="#f97316" style="background-color: #f97316;"></div>
                        <div class="dtmc-color-swatch" data-color="#ec4899" style="background-color: #ec4899;"></div>
                        <div class="dtmc-color-swatch" data-color="#6366f1" style="background-color: #6366f1;"></div>
                        <div class="dtmc-color-swatch" data-color="#10b981" style="background-color: #10b981;"></div>
                        <div class="dtmc-color-swatch" data-color="#fbbf24" style="background-color: #fbbf24;"></div>
                        <div class="dtmc-color-swatch" data-color="#6b7280" style="background-color: #6b7280;"></div>
                        <div class="dtmc-color-swatch" data-color="#9ca3af" style="background-color: #9ca3af;"></div>
                        <div class="dtmc-color-swatch" data-color="#d1d5db" style="background-color: #d1d5db;"></div>
                        <div class="dtmc-color-swatch" data-color="#000000" style="background-color: #000000;"></div>
                    </div>
                    <div class="dtmc-form-group">
                        <label for="token-value" class="dtmc-form-label">Custom Color (Hex)</label>
                        <input type="text" id="token-value" class="dtmc-form-input" placeholder="#4a90e2" maxlength="7">
                    </div>
                </div>
                
                <!-- Non-Primitive Layer Section -->
                <div id="reference-token-section" class="dtmc-token-section" style="display: none;">
                    <label class="dtmc-form-label">Select from existing tokens:</label>
                    <select id="token-reference-dropdown" class="dtmc-form-select">
                        <option value="">Select from existing tokens...</option>
                    </select>
                    <div class="dtmc-tip">
                        <span class="dtmc-tip-icon">üí°</span>
                        <span id="available-tokens-count">0 tokens available</span>
                    </div>
                    <div class="dtmc-form-group">
                        <label for="token-value-custom" class="dtmc-form-label">Or enter a custom value:</label>
                        <input type="text" id="token-value-custom" class="dtmc-form-input" placeholder="Enter custom value or select from dropdown above">
                    </div>
                </div>
                
                <!-- Simple Value Section -->
                <div id="simple-value-section" class="dtmc-token-section" style="display: none;">
                    <div class="dtmc-form-group">
                        <label for="token-value-simple" class="dtmc-form-label">Token Value</label>
                        <input type="text" id="token-value-simple" class="dtmc-form-input" placeholder="Enter value...">
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="dtmc-modal-footer">
                <button id="dtmc-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-create-btn" class="dtmc-modal-btn create">Create Token</button>
            </div>
        </div>
    </div>

    <!-- Drag Preview -->
    <div id="dtmc-drag-preview" class="dtmc-drag-preview" style="display: none;"></div>

    <!-- Save Session Modal -->
    <div id="dtmc-save-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Save Session</h3>
                <p class="dtmc-modal-subtitle">Save your current design token setup</p>
            </div>
            
            <div class="dtmc-form-group">
                <label for="session-name" class="dtmc-form-label">Session Name</label>
                <input type="text" id="session-name" class="dtmc-form-input" placeholder="e.g., My Design System v1">
            </div>
            
            <div class="dtmc-form-group">
                <label for="session-description" class="dtmc-form-label">Description (optional)</label>
                <textarea id="session-description" class="dtmc-form-input" placeholder="Brief description of this session..." rows="3"></textarea>
            </div>
            
            <div class="dtmc-form-group">
                <label class="dtmc-form-label">Session Info</label>
                <div class="dtmc-session-info">
                    <div class="dtmc-session-stat">
                        <span class="dtmc-session-stat-label">Tokens:</span>
                        <span id="save-token-count" class="dtmc-session-stat-value">0</span>
                    </div>
                    <div class="dtmc-session-stat">
                        <span class="dtmc-session-stat-label">Connections:</span>
                        <span id="save-connection-count" class="dtmc-session-stat-value">0</span>
                    </div>
                    <div class="dtmc-session-stat">
                        <span class="dtmc-session-stat-label">Last Modified:</span>
                        <span id="save-last-modified" class="dtmc-session-stat-value">Now</span>
                    </div>
                </div>
            </div>
            
            <div class="dtmc-modal-footer">
                <button id="dtmc-save-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-save-confirm-btn" class="dtmc-modal-btn create">Save Session</button>
            </div>
        </div>
    </div>

    <!-- Load Session Modal -->
    <div id="dtmc-load-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Load Session</h3>
                <p class="dtmc-modal-subtitle">Load a previously saved session</p>
            </div>
            
            <div class="dtmc-form-group">
                <label class="dtmc-form-label">Saved Sessions</label>
                <div id="dtmc-sessions-list" class="dtmc-sessions-list">
                    <!-- Sessions will be populated here -->
                </div>
            </div>
            
            <div class="dtmc-form-group">
                <div class="dtmc-load-warning">
                    <span class="dtmc-warning-icon">‚ö†Ô∏è</span>
                    <span>Loading a session will replace your current setup. Make sure to save any unsaved changes.</span>
                </div>
            </div>
            
            <div class="dtmc-modal-footer">
                <button id="dtmc-load-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-load-confirm-btn" class="dtmc-modal-btn create" disabled>Load Selected Session</button>
            </div>
        </div>
    </div>

    <script>
        // Helper function to get CSS variables
        function getCSSVariable(variableName) {
            return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
        }
        
        // Helper function to parse CSS values
        function parseCSSValue(value) {
            if (value.includes('px')) {
                return parseFloat(value);
            } else if (value.includes('rgba')) {
                return value; // Return as is for rgba values
            } else if (value.includes('#')) {
                return value; // Return as is for hex colors
            } else {
                return parseFloat(value);
            }
        }
        
        // Canvas setup
        const canvas = document.getElementById('dtmc-canvas');
        const ctx = canvas.getContext('2d');
        
        // Constants
        const SOCKET_RADIUS = 9; // 18px diameter = 9px radius
        const NODE_WIDTH = 200;
        const NODE_HEIGHT = 120;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        
        // State
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let selectedConnection = null;
        let isDragging = false;
        let isPanning = false;
        let panOffset = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let zoomLevel = 1.0;               // Current zoom level
        let isConnecting = false;
        let connectionStart = null;
        let startSocket = null;
        let endSocket = null;
        let selectedTokenType = 'color';
        let selectedLayer = null;
        let tokens = {
            primitive: [],
            base: [],
            semantic: [],
            specific: []
        };
        let undoStack = [];
        let dragPreview = null;
        let draggedToken = null;

        // Initialize
        function init() {
            console.log('üéØ DTMC Enhanced Interactive Sidebar System Loaded!');
            console.log('Features: Enhanced Modal, Color Palette, Reference System, Token Types, Layers, Drag & Drop, Zoom Controls, Mini-map, Connection Labels');
            console.log('Keyboard Shortcuts: Ctrl+M (Toggle Mini-map), Ctrl+0 (Reset Zoom), Delete/Backspace (Delete Connections)');
            
            setupEventListeners();
            setupSidebar();
            loadSampleTokens();
            resizeCanvas();
            updateZoomDisplay();
            render();
            setupColorSwatchEvents();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Canvas events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Control buttons
            document.getElementById('dtmc-clear-btn').addEventListener('click', clearAll);
            document.getElementById('dtmc-undo-btn').addEventListener('click', () => {
                console.log('üîò Undo button clicked!');
                console.log('Undo stack length:', undoStack.length);
                undo();
            });
            document.getElementById('dtmc-export-btn').addEventListener('click', exportJSON);
            
            // Zoom controls
            document.getElementById('dtmc-zoom-in-btn').addEventListener('click', () => zoomIn());
            document.getElementById('dtmc-zoom-out-btn').addEventListener('click', () => zoomOut());
            document.getElementById('dtmc-reset-zoom-btn').addEventListener('click', () => resetZoom());
            
            // Save/Load session buttons
            document.getElementById('dtmc-save-btn').addEventListener('click', showSaveModal);
            document.getElementById('dtmc-load-btn').addEventListener('click', showLoadModal);
            
            // Mini-map controls
            document.getElementById('dtmc-minimap-toggle').addEventListener('click', toggleMiniMap);
            
            // Mini-map click navigation
            document.getElementById('dtmc-minimap-canvas').addEventListener('click', handleMiniMapClick);
            
            // Modal events
            document.getElementById('dtmc-cancel-btn').addEventListener('click', closeModal);
            document.getElementById('dtmc-create-btn').addEventListener('click', createToken);
            
            // Window events
            window.addEventListener('resize', resizeCanvas);
            
            // Keyboard events for connection deletion
            document.addEventListener('keydown', handleKeyDown);
        }

        // Setup sidebar functionality
        function setupSidebar() {
            // Token type selection
            document.querySelectorAll('.dtmc-type-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.dtmc-type-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedTokenType = btn.dataset.type;
                    console.log('Selected token type:', selectedTokenType);
                });
            });

            // Add token buttons
            document.querySelectorAll('.dtmc-add-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('üîò Add button clicked!');
                    console.log('Button dataset:', btn.dataset);
                    selectedLayer = btn.dataset.layer;
                    console.log('Selected layer set to:', selectedLayer);
                    openModal();
                });
            });
        }

        // Load sample tokens
        function loadSampleTokens() {
            tokens.primitive = [
                { name: 'primary-blue', value: '#4a90e2', type: 'color' },
                { name: 'secondary-purple', value: '#805ad5', type: 'color' },
                { name: 'font-size-base', value: '16px', type: 'number' }
            ];
            
            tokens.base = [
                { name: 'color-brand', value: '{primitive.primary-blue}', type: 'color' }
            ];
            
            tokens.semantic = [
                { name: 'button-bg', value: '{base.color-brand}', type: 'color' }
            ];
            
            tokens.specific = [];
            
            renderSidebar();
        }

        // Render sidebar
        function renderSidebar() {
            Object.keys(tokens).forEach(layer => {
                const container = document.getElementById(`${layer}-tokens`);
                container.innerHTML = '';
                
                tokens[layer].forEach(token => {
                    const tokenElement = createTokenElement(token, layer);
                    container.appendChild(tokenElement);
                });
            });
        }

        // Create token element for sidebar
        function createTokenElement(token, layer) {
            const div = document.createElement('div');
            div.className = 'dtmc-token-item';
            div.draggable = true;
            div.dataset.tokenName = token.name;
            div.dataset.tokenValue = token.value;
            div.dataset.tokenType = token.type;
            div.dataset.tokenLayer = layer;
            
            div.innerHTML = `
                <div class="dtmc-token-name">${token.name}</div>
                <div class="dtmc-token-value">${token.value}</div>
            `;
            
            div.addEventListener('dragstart', (e) => {
                draggedToken = { ...token, layer };
                e.dataTransfer.setData('text/plain', JSON.stringify(draggedToken));
                dragPreview.style.display = 'block';
                dragPreview.textContent = `${token.name} (${token.value})`;
            });
            
            div.addEventListener('dragend', () => {
                dragPreview.style.display = 'none';
            });
            
            return div;
        }

        // Open modal for token creation
        function openModal() {
            console.log('üîç Opening modal...');
            console.log('Selected token type:', selectedTokenType);
            console.log('Selected layer:', selectedLayer);
            
            const modal = document.getElementById('dtmc-token-modal');
            const modalTitle = document.querySelector('.dtmc-modal-title');
            
            if (!modal) {
                console.error('‚ùå Modal not found!');
                return;
            }
            
            if (!modalTitle) {
                console.error('‚ùå Modal title not found!');
                return;
            }
            
            console.log('‚úÖ Modal and title found');
            
            // Update modal title
            modalTitle.textContent = `Create New ${selectedTokenType.charAt(0).toUpperCase() + selectedTokenType.slice(1)} Token`;
            
            // Show appropriate value section
            showAppropriateValueSection();
            
            // Populate reference dropdown if needed
            if (selectedLayer !== 'primitive') {
                populateReferenceDropdown();
            }
            
            modal.style.display = 'flex';
            console.log('üéâ Modal opened successfully!');
        }

        // Show appropriate value section based on token type and layer
        function showAppropriateValueSection() {
            const colorSection = document.getElementById('color-token-section');
            const referenceSection = document.getElementById('reference-token-section');
            const simpleSection = document.getElementById('simple-value-section');
            
            // Hide all sections first
            colorSection.style.display = 'none';
            referenceSection.style.display = 'none';
            simpleSection.style.display = 'none';
            
            if (selectedTokenType === 'color' && selectedLayer === 'primitive') {
                // Color tokens in primitive layer show color palette
                colorSection.style.display = 'block';
            } else if (selectedLayer !== 'primitive') {
                // Non-primitive layers show reference dropdown
                referenceSection.style.display = 'block';
            } else {
                // Other token types show simple input
                simpleSection.style.display = 'block';
            }
        }

        // Populate reference dropdown with available tokens
        function populateReferenceDropdown() {
            const dropdown = document.getElementById('token-reference-dropdown');
            const countSpan = document.getElementById('available-tokens-count');
            
            // Clear existing options
            dropdown.innerHTML = '<option value="">Select from existing tokens...</option>';
            
            let availableTokens = [];
            
            // Collect tokens from all layers except the current one
            Object.keys(tokens).forEach(layer => {
                if (layer !== selectedLayer) {
                    tokens[layer].forEach(token => {
                        availableTokens.push({
                            layer: layer,
                            name: token.name,
                            value: token.value,
                            displayText: `${layer}.${token.name} (${token.value})`
                        });
                    });
                }
            });
            
            // Add options to dropdown
            availableTokens.forEach(token => {
                const option = document.createElement('option');
                option.value = JSON.stringify(token);
                option.textContent = token.displayText;
                dropdown.appendChild(option);
            });
            
            // Update count
            countSpan.textContent = `${availableTokens.length} tokens available`;
            
            // Add change event listener
            dropdown.onchange = function() {
                const selectedValue = this.value;
                if (selectedValue) {
                    const tokenData = JSON.parse(selectedValue);
                    document.getElementById('token-value-custom').value = `{${tokenData.layer}.${tokenData.name}}`;
                }
            };
        }

        // Setup color swatch click events
        function setupColorSwatchEvents() {
            const colorSwatches = document.querySelectorAll('.dtmc-color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', function() {
                    // Remove selected class from all swatches
                    colorSwatches.forEach(s => s.classList.remove('selected'));
                    // Add selected class to clicked swatch
                    this.classList.add('selected');
                    // Update the token value input
                    const colorValue = this.getAttribute('data-color');
                    document.getElementById('token-value').value = colorValue;
                });
            });
        }

        // Close modal
        function closeModal() {
            const modal = document.getElementById('dtmc-token-modal');
            modal.style.display = 'none';
            
            // Clear all inputs
            document.getElementById('token-name').value = '';
            document.getElementById('token-value').value = '';
            document.getElementById('token-value-custom').value = '';
            document.getElementById('token-value-simple').value = '';
            
            // Reset color swatch selection
            document.querySelectorAll('.dtmc-color-swatch').forEach(s => s.classList.remove('selected'));
            
            // Reset dropdown
            document.getElementById('token-reference-dropdown').selectedIndex = 0;
        }

        // Create token
        function createToken() {
            const name = document.getElementById('token-name').value.trim();
            let value = '';
            
            // Get value from appropriate input field
            if (selectedTokenType === 'color' && selectedLayer === 'primitive') {
                value = document.getElementById('token-value').value.trim();
            } else if (selectedLayer !== 'primitive') {
                value = document.getElementById('token-value-custom').value.trim();
            } else {
                value = document.getElementById('token-value-simple').value.trim();
            }
            
            if (!name || !value) {
                alert('Please fill in both name and value');
                return;
            }
            
            const newToken = {
                name,
                value,
                type: selectedTokenType
            };
            
            tokens[selectedLayer].push(newToken);
            renderSidebar();
            closeModal();
            
            // Update any existing nodes with this token
            updateNodesWithToken(newToken);
            
            console.log(`Created ${selectedLayer} token:`, newToken);
        }

        // Mouse event handlers
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Check if clicking on a socket
            const socketInfo = getSocketAtPoint(x, y);
            if (socketInfo) {
                isConnecting = true;
                connectionStart = socketInfo.node;
                startSocket = socketInfo.socket;
                return;
            }
            
            // Check if clicking on a connection line
            const clickedConnection = getConnectionAtPoint(x, y);
            if (clickedConnection) {
                console.log('Clicked on connection:', clickedConnection);
                
                // Select the connection (will be drawn in red)
                selectedConnection = clickedConnection;
                selectedNode = null; // Deselect any selected node
                
                // Re-render to show selected connection
                render();
                return;
            }
            
            // Check if clicking on a node
            const clickedNode = getNodeAtPoint(x, y);
            if (clickedNode) {
                selectedNode = clickedNode;
                selectedConnection = null; // Deselect any selected connection
                isDragging = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                return;
            }
            
            // Deselect if clicking on empty space
            if (selectedNode || selectedConnection) {
                selectedNode = null;
                selectedConnection = null;
                render();
            }
            
            // Start panning
            isPanning = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
        }

        function handleMouseMove(e) {
            if (isConnecting) {
                // Handle connection preview
                render();
                drawConnectionPreview(e);
                return;
            }
            
            if (isDragging && selectedNode) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                selectedNode.x += deltaX;
                selectedNode.y += deltaY;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                
                // Ensure connections are updated when node moves
                console.log(`Node ${selectedNode.name} moved to (${selectedNode.x}, ${selectedNode.y})`);
                console.log(`Active connections: ${connections.length}`);
                
                render();
                return;
            }
            
            if (isPanning) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                panOffset.x += deltaX;
                panOffset.y += deltaY;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                render();
            }
            
            // Update cursor based on what's under the mouse
            updateCursor(e);
        }

        function handleMouseUp(e) {
            if (isConnecting) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
                const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
                
                const socketInfo = getSocketAtPoint(x, y);
                if (socketInfo && socketInfo.node !== connectionStart) {
                    // Validate connection (output to input only)
                    if ((startSocket === 'right' || startSocket === 'bottom') && 
                        (socketInfo.socket === 'top' || socketInfo.socket === 'left')) {
                        
                        // Store original value if not already stored
                        if (!socketInfo.node.originalValue) {
                            socketInfo.node.originalValue = socketInfo.node.value;
                            console.log(`Stored original value for ${socketInfo.node.name}: ${socketInfo.node.originalValue}`);
                        }
                        
                        const connection = {
                            startNode: connectionStart,
                            endNode: socketInfo.node,
                            startSocket: startSocket,
                            endSocket: socketInfo.socket
                        };
                        
                        connections.push(connection);
                        saveState();
                        
                        // Update the target node's value to show the reference path to the source
                        const referencePath = `{${connectionStart.layer}.${connectionStart.name}}`;
                        socketInfo.node.value = referencePath;
                        socketInfo.node.currentValue = referencePath;
                        
                        // Also update the corresponding token in the tokens object for sidebar and JSON export
                        const targetLayer = socketInfo.node.layer;
                        const targetToken = tokens[targetLayer]?.find(t => t.name === socketInfo.node.name);
                        if (targetToken) {
                            targetToken.value = referencePath;
                            console.log(`Updated token ${targetLayer}.${socketInfo.node.name} to: ${referencePath}`);
                        }
                        
                        // Re-render sidebar to show updated values
                        renderSidebar();
                        
                        console.log(`Reference created: ${connectionStart.name} ‚Üí ${socketInfo.node.name} with path: ${referencePath}`);
                    } else {
                        console.warn('Invalid connection: Can only connect output to input sockets');
                    }
                }
                
                isConnecting = false;
                connectionStart = null;
                startSocket = null;
                render();
                return;
            }
            
            isDragging = false;
            isPanning = false;
            selectedNode = null;
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate zoom factor
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * zoomFactor));
            
            if (newZoom !== zoomLevel) {
                // Calculate zoom center relative to canvas
                const zoomCenterX = (mouseX - panOffset.x) / zoomLevel;
                const zoomCenterY = (mouseY - panOffset.y) / zoomLevel;
                
                // Update zoom level
                zoomLevel = newZoom;
                
                // Adjust pan offset to zoom towards mouse position
                panOffset.x = mouseX - zoomCenterX * zoomLevel;
                panOffset.y = mouseY - zoomCenterY * zoomLevel;
                
                // Re-render with new zoom
                render();
            }
        }

        // Helper functions
        function getNodeAtPoint(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (x >= node.x && x <= node.x + NODE_WIDTH &&
                    y >= node.y && y <= node.y + NODE_HEIGHT) {
                    return node;
                }
            }
            return null;
        }

        function getSocketAtPoint(x, y) {
            for (const node of nodes) {
                const sockets = [
                    { x: node.x + NODE_WIDTH / 2, y: node.y, type: 'input', socket: 'top' },
                    { x: node.x, y: node.y + NODE_HEIGHT / 2, type: 'input', socket: 'left' },
                    { x: node.x + NODE_WIDTH, y: node.y + NODE_HEIGHT / 2, type: 'output', socket: 'right' },
                    { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT, type: 'output', socket: 'bottom' }
                ];
                
                for (const socket of sockets) {
                    const distance = Math.sqrt((x - socket.x) ** 2 + (y - socket.y) ** 2);
                    if (distance <= SOCKET_RADIUS) {
                        return { node, ...socket };
                    }
                }
            }
            return null;
        }

        // Check if a point is near a connection line
        function getConnectionAtPoint(x, y) {
            const CLICK_TOLERANCE = 8; // How close to the line you need to click
            
            for (const connection of connections) {
                const startPoint = getSocketPosition(connection.startNode, connection.startSocket);
                const endPoint = getSocketPosition(connection.endNode, connection.endSocket);
                
                // Calculate distance from point to line segment
                const distance = distanceToLineSegment(x, y, startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                
                if (distance <= CLICK_TOLERANCE) {
                    return connection;
                }
            }
            return null;
        }

        // Calculate distance from point to line segment
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) {
                // Point is at start point
                return Math.sqrt(A * A + B * B);
            }
            
            let param = dot / lenSq;
            
            if (param < 0) {
                // Closest point is start point
                return Math.sqrt(A * A + B * B);
            } else if (param > 1) {
                // Closest point is end point
                return Math.sqrt((px - x2) * (px - x2) + (py - y2) * (py - y2));
            } else {
                // Closest point is on the line segment
                const x = x1 + param * C;
                const y = y1 + param * D;
                return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y));
            }
        }

        function drawConnectionPreview(e) {
            if (!connectionStart) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Get CSS variables for connection preview styling
            const connectionPreviewColor = getCSSVariable('--dtmc-connection-preview-color');
            const connectionWidth = parseCSSValue(getCSSVariable('--dtmc-connection-width'));
            
            ctx.strokeStyle = connectionPreviewColor;
            ctx.lineWidth = connectionWidth;
            ctx.setLineDash([5, 5]);
            
            const startPoint = getSocketPosition(connectionStart, startSocket);
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function getSocketPosition(node, socket) {
            switch (socket) {
                case 'top': return { x: node.x + NODE_WIDTH / 2, y: node.y };
                case 'left': return { x: node.x, y: node.y + NODE_HEIGHT / 2 };
                case 'right': return { x: node.x + NODE_WIDTH, y: node.y + NODE_HEIGHT / 2 };
                case 'bottom': return { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT };
                default: return { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT / 2 };
            }
        }

        // Canvas drop handling
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Create new node from token
            const newNode = {
                id: Date.now(),
                x: x - NODE_WIDTH / 2,
                y: y - NODE_HEIGHT / 2,
                name: draggedToken.name,
                value: draggedToken.value,
                type: draggedToken.type,
                layer: draggedToken.layer,
                originalValue: draggedToken.value // Store original value for restoration
            };
            
            nodes.push(newNode);
            saveState();
            render();
            
            console.log('Created node from token:', newNode);
        });

        // Rendering functions
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(zoomLevel, zoomLevel);
            
            // Draw connections first
            console.log(`Rendering ${connections.length} connections`);
            connections.forEach((connection, index) => {
                console.log(`Drawing connection ${index + 1}: ${connection.startNode.name} ‚Üí ${connection.endNode.name}`);
                drawConnection(connection.startNode, connection.endNode, connection.startSocket, connection.endSocket);
            });
            
            // Draw nodes on top
            nodes.forEach(node => {
                drawNode(node);
            });
            
            ctx.restore();
            
            // Update mini-map if visible
            const minimap = document.querySelector('.dtmc-minimap');
            if (minimap && !minimap.classList.contains('hidden')) {
                renderMiniMap();
            }
        }

        function drawNode(node) {
            // Check if node is selected
            const isSelected = selectedNode && selectedNode.id === node.id;
            
            // Get CSS variables for bubble styling
            const bubbleBgColor = getCSSVariable('--dtmc-bubble-bg-color');
            const bubbleBlur = parseCSSValue(getCSSVariable('--dtmc-bubble-blur'));
            const bubbleRadius = parseCSSValue(getCSSVariable('--dtmc-bubble-radius'));
            const bubbleShadowColor = getCSSVariable('--dtmc-bubble-shadow-color');
            const bubbleNameColor = getCSSVariable('--dtmc-bubble-name-color');
            const bubbleNameFontSize = getCSSVariable('--dtmc-bubble-name-font-size');
            const bubbleNameYOffset = parseCSSValue(getCSSVariable('--dtmc-bubble-name-y-offset'));
            
            // Draw node background with CSS-controlled styling
            ctx.fillStyle = bubbleBgColor;
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = isSelected ? 3 : 2;
            
            // Apply backdrop blur effect (simulated with shadow)
            ctx.shadowColor = bubbleShadowColor;
            ctx.shadowBlur = bubbleBlur;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.beginPath();
            ctx.roundRect(node.x, node.y, NODE_WIDTH, NODE_HEIGHT, bubbleRadius);
            ctx.fill();
            
            // Reset shadow for border
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw gradient border based on layer type
            drawGradientBorder(node);
            
            // Node content
            ctx.textAlign = 'center';
            
            // Token name with CSS-controlled styling
            ctx.fillStyle = bubbleNameColor;
            ctx.font = `${bubbleNameFontSize} Sora, system-ui, sans-serif`;
            ctx.fillText(node.name, node.x + NODE_WIDTH / 2, node.y + bubbleNameYOffset);
            
            // Token value in black background container
            drawValueContainer(node);
            
            // Draw sockets
            drawSockets(node);
        }
        
        function drawGradientBorder(node) {
            // Get CSS variables for border styling
            const borderWidth = parseCSSValue(getCSSVariable('--dtmc-bubble-border-width'));
            const borderRadius = parseCSSValue(getCSSVariable('--dtmc-bubble-border-radius'));
            const borderEndColor = getCSSVariable('--dtmc-bubble-border-end-color');
            
            let startColor, endColor;
            
            // Set gradient colors based on layer type using CSS variables
            switch (node.layer) {
                case 'primitive':
                    startColor = getCSSVariable('--dtmc-primitive-start');
                    endColor = getCSSVariable('--dtmc-primitive-end');
                    break;
                case 'base':
                    startColor = getCSSVariable('--dtmc-base-start');
                    endColor = getCSSVariable('--dtmc-base-end');
                    break;
                case 'semantic':
                    startColor = getCSSVariable('--dtmc-semantic-start');
                    endColor = getCSSVariable('--dtmc-semantic-end');
                    break;
                case 'specific':
                    startColor = getCSSVariable('--dtmc-specific-start');
                    endColor = getCSSVariable('--dtmc-specific-end');
                    break;
                default:
                    startColor = getCSSVariable('--dtmc-primitive-start');
                    endColor = getCSSVariable('--dtmc-primitive-end');
            }
            
            // Create gradient outline by drawing the border as a stroke
            ctx.lineWidth = borderWidth;
            
            // Create gradient for the border
            const gradient = ctx.createLinearGradient(
                node.x, node.y, 
                node.x, node.y + NODE_HEIGHT / 2
            );
            gradient.addColorStop(0, startColor);
            gradient.addColorStop(1, endColor);
            
            // Draw the border with gradient
            ctx.strokeStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(node.x + borderWidth/2, node.y + borderWidth/2, NODE_WIDTH - borderWidth, NODE_HEIGHT - borderWidth, borderRadius);
            ctx.stroke();
            
            // Draw the bottom half with solid color
            ctx.strokeStyle = borderEndColor;
            ctx.beginPath();
            ctx.moveTo(node.x + borderWidth/2, node.y + NODE_HEIGHT / 2);
            ctx.lineTo(node.x + NODE_WIDTH - borderWidth/2, node.y + NODE_HEIGHT / 2);
            ctx.lineTo(node.x + NODE_WIDTH - borderWidth/2, node.y + NODE_HEIGHT - borderWidth/2);
            ctx.lineTo(node.x + borderWidth/2, node.y + NODE_HEIGHT - borderWidth/2);
            ctx.closePath();
            ctx.stroke();
        }
        
        function drawValueContainer(node) {
            // Get CSS variables for value container styling
            const containerBg = getCSSVariable('--dtmc-value-container-bg');
            const containerRadius = parseCSSValue(getCSSVariable('--dtmc-value-container-radius'));
            const containerMarginX = parseCSSValue(getCSSVariable('--dtmc-value-container-margin-x'));
            const containerYOffset = parseCSSValue(getCSSVariable('--dtmc-value-container-y-offset'));
            const containerHeight = parseCSSValue(getCSSVariable('--dtmc-value-container-height'));
            const valueTextColor = getCSSVariable('--dtmc-value-text-color');
            const valueTextFontSize = getCSSVariable('--dtmc-value-text-font-size');
            
            const containerX = node.x + containerMarginX;
            const containerY = node.y + containerYOffset;
            const containerWidth = NODE_WIDTH - (containerMarginX * 2);
            
            // Draw background container
            ctx.fillStyle = containerBg;
            ctx.beginPath();
            ctx.roundRect(containerX, containerY, containerWidth, containerHeight, containerRadius);
            ctx.fill();
            
            // Draw value text
            ctx.fillStyle = valueTextColor;
            ctx.font = `${valueTextFontSize} Sora, system-ui, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(node.value, node.x + NODE_WIDTH / 2, containerY + containerHeight/2 + 4);
        }
        
        function drawSockets(node) {
            // Check which sockets are connected
            const connectedSockets = new Set();
            connections.forEach(connection => {
                if (connection.startNode.id === node.id) {
                    connectedSockets.add(connection.startSocket);
                }
                if (connection.endNode.id === node.id) {
                    connectedSockets.add(connection.endSocket);
                }
            });
            
            // Top socket (INPUT - red)
            const topSocket = { x: node.x + NODE_WIDTH / 2, y: node.y };
            drawSocket(topSocket.x, topSocket.y, 'input', connectedSockets.has('top'));
            
            // Left socket (INPUT - red)
            const leftSocket = { x: node.x, y: node.y + NODE_HEIGHT / 2 };
            drawSocket(leftSocket.x, leftSocket.y, 'input', connectedSockets.has('left'));
            
            // Right socket (OUTPUT - green)
            const rightSocket = { x: node.x + NODE_WIDTH, y: node.y + NODE_HEIGHT / 2 };
            drawSocket(rightSocket.x, rightSocket.y, 'output', connectedSockets.has('right'));
            
            // Bottom socket (OUTPUT - green)
            const bottomSocket = { x: node.x + NODE_WIDTH / 2, y: node.y + NODE_HEIGHT };
            drawSocket(bottomSocket.x, bottomSocket.y, 'output', connectedSockets.has('bottom'));
        }
        
        function drawSocket(x, y, type, isConnected) {
            // Get CSS variables for socket styling
            const socketRadius = parseCSSValue(getCSSVariable('--dtmc-socket-radius'));
            const socketConnectedColor = getCSSVariable('--dtmc-socket-connected-color');
            const socketDisconnectedColor = getCSSVariable('--dtmc-socket-disconnected-color');
            const socketStrokeColor = getCSSVariable('--dtmc-socket-stroke-color');
            const socketStrokeWidth = parseCSSValue(getCSSVariable('--dtmc-socket-stroke-width'));
            const socketInnerCircleRadius = parseCSSValue(getCSSVariable('--dtmc-socket-inner-circle-radius'));
            const socketPlusSize = parseCSSValue(getCSSVariable('--dtmc-socket-plus-size'));
            
            // Draw socket background
            if (isConnected) {
                ctx.fillStyle = socketConnectedColor;
            } else {
                ctx.fillStyle = socketDisconnectedColor;
            }
            
            ctx.beginPath();
            ctx.arc(x, y, socketRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw socket content
            if (isConnected) {
                // When connected, just fill with connected color
                ctx.strokeStyle = socketConnectedColor;
                ctx.lineWidth = socketStrokeWidth;
                ctx.stroke();
            } else {
                // When not connected, draw appropriate symbol
                ctx.strokeStyle = socketStrokeColor;
                ctx.lineWidth = socketStrokeWidth;
                ctx.stroke();
                
                if (type === 'input') {
                    // Draw small circle inside for input sockets
                    ctx.fillStyle = socketStrokeColor;
                    ctx.beginPath();
                    ctx.arc(x, y, socketInnerCircleRadius, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // Draw plus sign for output sockets
                    ctx.strokeStyle = socketStrokeColor;
                    ctx.lineWidth = socketStrokeWidth;
                    ctx.beginPath();
                    ctx.moveTo(x - socketPlusSize, y);
                    ctx.lineTo(x + socketPlusSize, y);
                    ctx.moveTo(x, y - socketPlusSize);
                    ctx.lineTo(x, y + socketPlusSize);
                    ctx.stroke();
                }
            }
        }
        
        function drawConnection(startNode, endNode, startSocket, endSocket) {
            const startPoint = getSocketPosition(startNode, startSocket);
            const endPoint = getSocketPosition(endNode, endSocket);
            
            // Get CSS variables for connection styling
            const connectionColor = getCSSVariable('--dtmc-connection-color');
            const connectionWidth = parseCSSValue(getCSSVariable('--dtmc-connection-width'));
            const connectionSelectedWidth = parseCSSValue(getCSSVariable('--dtmc-connection-selected-width'));
            
            // Check if this connection is selected
            const isSelected = selectedConnection && 
                selectedConnection.startNode.id === startNode.id && 
                selectedConnection.endNode.id === endNode.id &&
                selectedConnection.startSocket === startSocket && 
                selectedConnection.endSocket === endSocket;
            
            // Draw connections with CSS-controlled styling
            if (isSelected) {
                ctx.strokeStyle = connectionColor;
                ctx.lineWidth = connectionSelectedWidth;
            } else {
                ctx.strokeStyle = connectionColor;
                ctx.lineWidth = connectionWidth;
            }
            
            // Create curved connection
            const controlPoint1 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: startPoint.y
            };
            
            const controlPoint2 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: endPoint.y
            };
            
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.bezierCurveTo(
                controlPoint1.x, controlPoint1.y,
                controlPoint2.x, controlPoint2.y,
                endPoint.x, endPoint.y
            );
            ctx.stroke();
            
            // Draw connection label
            drawConnectionLabel(startPoint, endPoint, startNode, endNode);
        }

        // Utility functions
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            render();
        }

        function saveState() {
            undoStack.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections))
            });
            
            if (undoStack.length > 20) {
                undoStack.shift();
            }
        }

        function undo() {
            console.log('üîÑ Undo function called');
            console.log('Current undo stack length:', undoStack.length);
            
            if (undoStack.length > 0) {
                const previousState = undoStack.pop();
                console.log('‚úÖ Restoring previous state:', previousState);
                nodes = previousState.nodes;
                connections = previousState.connections;
                render();
                console.log('üéâ Undo completed');
            } else {
                console.log('‚ö†Ô∏è Nothing to undo');
            }
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all nodes and connections?')) {
                nodes = [];
                connections = [];
                undoStack = [];
                render();
            }
        }

        function exportJSON() {
            const data = {
                tokens: tokens,
                nodes: nodes,
                connections: connections
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dtmc-enhanced-tokens.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Update nodes when tokens change
        function updateNodesWithToken(token) {
            nodes.forEach(node => {
                if (node.name === token.name && node.layer === selectedLayer) {
                    node.value = token.value;
                    console.log(`Updated existing node: ${node.name} with value: ${node.value}`);
                }
            });
            render();
        }

        // Update cursor based on what's under the mouse
        function updateCursor(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Check if hovering over a connection
            const connectionUnderMouse = getConnectionAtPoint(x, y);
            if (connectionUnderMouse) {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'grab';
            }
        }

        // Zoom control functions
        function zoomIn() {
            const newZoom = Math.min(MAX_ZOOM, zoomLevel * 1.2);
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                updateZoomDisplay();
                render();
            }
        }

        function zoomOut() {
            const newZoom = Math.max(MIN_ZOOM, zoomLevel / 1.2);
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                updateZoomDisplay();
                render();
            }
        }

        function resetZoom() {
            zoomLevel = 1.0;
            panOffset = { x: 0, y: 0 };
            updateZoomDisplay();
            render();
        }

        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('dtmc-zoom-level');
            zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
        }

        // Draw connection labels
        function drawConnectionLabel(startPoint, endPoint, startNode, endNode) {
            // Calculate label position (middle of the connection)
            const labelX = (startPoint.x + endPoint.x) / 2;
            const labelY = (startPoint.y + endPoint.y) / 2;
            
            // Create label text
            const labelText = `${startNode.name} ‚Üí ${endNode.name}`;
            
            // Set text style
            ctx.font = '12px Inter, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw label background
            const textMetrics = ctx.measureText(labelText);
            const padding = 4;
            const bgWidth = textMetrics.width + padding * 2;
            const bgHeight = 16;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);
            
            // Draw label text
            ctx.fillStyle = '#ffffff';
            ctx.fillText(labelText, labelX, labelY);
        }

        // Mini-map functionality
        function toggleMiniMap() {
            const minimap = document.querySelector('.dtmc-minimap');
            minimap.classList.toggle('hidden');
            
            if (!minimap.classList.contains('hidden')) {
                renderMiniMap();
            }
        }

        function renderMiniMap() {
            const minimapCanvas = document.getElementById('dtmc-minimap-canvas');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            if (nodes.length === 0) return;
            
            // Calculate bounds of all nodes
            let minX = Math.min(...nodes.map(n => n.x));
            let maxX = Math.max(...nodes.map(n => n.x + NODE_WIDTH));
            let minY = Math.min(...nodes.map(n => n.y));
            let maxY = Math.max(...nodes.map(n => n.y + NODE_HEIGHT));
            
            // Add padding
            const padding = 50;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            // Calculate scale to fit in minimap
            const scaleX = minimapCanvas.width / (maxX - minX);
            const scaleY = minimapCanvas.height / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);
            
            // Draw nodes on minimap
            minimapCtx.fillStyle = '#3b82f6';
            nodes.forEach(node => {
                const minimapX = (node.x - minX) * scale;
                const minimapY = (node.y - minY) * scale;
                const minimapWidth = NODE_WIDTH * scale;
                const minimapHeight = NODE_HEIGHT * scale;
                
                minimapCtx.fillRect(minimapX, minimapY, minimapWidth, minimapHeight);
            });
            
            // Draw connections on minimap
            minimapCtx.strokeStyle = '#60a5fa';
            minimapCtx.lineWidth = 1;
            connections.forEach(connection => {
                const startPoint = getSocketPosition(connection.startNode, connection.startSocket);
                const endPoint = getSocketPosition(connection.endNode, connection.endSocket);
                
                const startX = (startPoint.x - minX) * scale;
                const startY = (startPoint.y - minY) * scale;
                const endX = (endPoint.x - minX) * scale;
                const endY = (endPoint.y - minY) * scale;
                
                minimapCtx.beginPath();
                minimapCtx.moveTo(startX, startY);
                minimapCtx.lineTo(endX, endY);
                minimapCtx.stroke();
            });
            
            // Draw viewport indicator
            const viewportX = (-panOffset.x - minX) * scale;
            const viewportY = (-panOffset.y - minY) * scale;
            const viewportWidth = (canvas.width / zoomLevel - minX) * scale;
            const viewportHeight = (canvas.height / zoomLevel - minY) * scale;
            
            minimapCtx.strokeStyle = '#fbbf24';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
        }

        // Handle mini-map clicks for navigation
        function handleMiniMapClick(e) {
            const minimapCanvas = document.getElementById('dtmc-minimap-canvas');
            const rect = minimapCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            if (nodes.length === 0) return;
            
            // Calculate bounds (same logic as renderMiniMap)
            let minX = Math.min(...nodes.map(n => n.x));
            let maxX = Math.max(...nodes.map(n => n.x + NODE_WIDTH));
            let minY = Math.min(...nodes.map(n => n.y));
            let maxY = Math.max(...nodes.map(n => n.y + NODE_HEIGHT));
            
            const padding = 50;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            const scaleX = minimapCanvas.width / (maxX - minX);
            const scaleY = minimapCanvas.height / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);
            
            // Convert click position to world coordinates
            const worldX = minX + (clickX / scale);
            const worldY = minY + (clickY / scale);
            
            // Center viewport on clicked position
            panOffset.x = -worldX + canvas.width / (2 * zoomLevel);
            panOffset.y = -worldY + canvas.height / (2 * zoomLevel);
            
            // Re-render
            render();
        }

        // Keyboard event handler for connection deletion
        function handleKeyDown(e) {
            // Handle Delete or Backspace for connection deletion
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedConnection) {
                e.preventDefault(); // Prevent default browser behavior
                
                console.log(`Delete key pressed for connection`);
                
                // Show confirmation dialog
                const startName = selectedConnection.startNode.name;
                const endName = selectedConnection.endNode.name;
                const confirmMessage = `Are you sure you want to delete the connection from "${startName}" to "${endName}"?\n\nThis will restore the original value of "${endName}".`;
                
                if (confirm(confirmMessage)) {
                    console.log(`User confirmed deletion of connection`);
                    deleteSelectedConnection();
                } else {
                    console.log(`User cancelled deletion of connection`);
                }
                return;
            }
            
            // Handle Ctrl+M for mini-map toggle
            if (e.ctrlKey && e.key === 'm') {
                e.preventDefault();
                toggleMiniMap();
                return;
            }
            
            // Handle Ctrl+0 for reset zoom
            if (e.ctrlKey && e.key === '0') {
                e.preventDefault();
                resetZoom();
                return;
            }
        }

        // Delete the currently selected connection
        function deleteSelectedConnection() {
            if (!selectedConnection) return;
            
            const startName = selectedConnection.startNode.name;
            const endName = selectedConnection.endNode.name;
            
            console.log(`Deleting connection from ${startName} to ${endName}`);
            console.log(`Target node ${endName} current value: ${selectedConnection.endNode.value}`);
            console.log(`Target node ${endName} original value: ${selectedConnection.endNode.originalValue}`);
            
            // Remove the connection
            const connectionIndex = connections.findIndex(conn => 
                conn.startNode.id === selectedConnection.startNode.id && 
                conn.endNode.id === selectedConnection.endNode.id &&
                conn.startSocket === selectedConnection.startSocket && 
                conn.endSocket === selectedConnection.endSocket
            );
            
            if (connectionIndex !== -1) {
                connections.splice(connectionIndex, 1);
                console.log(`Removed connection`);
            }
            
            // Restore the original value of the target node
            const targetNode = selectedConnection.endNode;
            
            // Find the original token value from the tokens object
            const targetLayer = targetNode.layer;
            const targetToken = tokens[targetLayer]?.find(t => t.name === targetNode.name);
            
            if (targetToken && targetNode.originalValue) {
                // Restore the node's value to its original value
                const oldValue = targetNode.value;
                targetNode.value = targetNode.originalValue;
                
                // Also restore the corresponding token in the tokens object
                targetToken.value = targetNode.originalValue;
                console.log(`Restored token ${targetLayer}.${targetNode.name}: ${oldValue} ‚Üí ${targetNode.originalValue}`);
                
                // Update sidebar
                renderSidebar();
            } else {
                console.warn(`No original value found for node ${targetNode.name}, cannot restore`);
            }
            
            // Clear selection
            selectedConnection = null;
            
            // Save state
            saveState();
            
            // Re-render
            render();
            
            console.log(`Successfully deleted connection from ${startName} to ${endName}`);
        }

        // ===== SAVE/LOAD SESSION FUNCTIONS =====
        
        // Show save session modal
        function showSaveModal() {
            const modal = document.getElementById('dtmc-save-modal');
            const sessionNameInput = document.getElementById('session-name');
            const sessionDescriptionInput = document.getElementById('session-description');
            const tokenCountSpan = document.getElementById('save-token-count');
            const connectionCountSpan = document.getElementById('save-connection-count');
            const lastModifiedSpan = document.getElementById('save-last-modified');
            
            // Update session info
            const totalTokens = Object.values(tokens).flat().length;
            const totalConnections = connections.length;
            
            tokenCountSpan.textContent = totalTokens;
            connectionCountSpan.textContent = totalConnections;
            lastModifiedSpan.textContent = new Date().toLocaleString();
            
            // Clear previous inputs
            sessionNameInput.value = '';
            sessionDescriptionInput.value = '';
            
            // Show modal
            modal.style.display = 'flex';
            sessionNameInput.focus();
            
            // Setup event listeners
            setupSaveModalEvents();
        }
        
        // Setup save modal event listeners
        function setupSaveModalEvents() {
            const modal = document.getElementById('dtmc-save-modal');
            const sessionNameInput = document.getElementById('session-name');
            const saveBtn = document.getElementById('dtmc-save-confirm-btn');
            const cancelBtn = document.getElementById('dtmc-save-cancel-btn');
            
            // Save button click
            saveBtn.onclick = () => {
                const sessionName = sessionNameInput.value.trim();
                if (!sessionName) {
                    alert('Please enter a session name');
                    return;
                }
                saveSession(sessionName);
            };
            
            // Cancel button click
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Enter key in name input
            sessionNameInput.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    saveBtn.click();
                }
            };
            
            // Click outside modal to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Save session to localStorage
        function saveSession(sessionName) {
            const sessionDescription = document.getElementById('session-description').value.trim();
            
            const sessionData = {
                name: sessionName,
                description: sessionDescription,
                timestamp: new Date().toISOString(),
                data: {
                    nodes: nodes,
                    connections: connections,
                    tokens: tokens,
                    panOffset: panOffset,
                    zoomLevel: zoomLevel
                }
            };
            
            // Get existing sessions
            const existingSessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            
            // Add new session (overwrite if name exists)
            existingSessions[sessionName] = sessionData;
            
            // Save to localStorage
            localStorage.setItem('dtmc-sessions', JSON.stringify(existingSessions));
            
            // Close modal
            document.getElementById('dtmc-save-modal').style.display = 'none';
            
            // Show success message
            showNotification(`Session "${sessionName}" saved successfully!`, 'success');
            
            console.log(`Session "${sessionName}" saved with ${nodes.length} nodes and ${connections.length} connections`);
        }
        
        // Show load session modal
        function showLoadModal() {
            const modal = document.getElementById('dtmc-load-modal');
            const sessionsList = document.getElementById('dtmc-sessions-list');
            
            // Load and display sessions
            loadSessionsList();
            
            // Show modal
            modal.style.display = 'flex';
            
            // Setup event listeners
            setupLoadModalEvents();
        }
        
        // Load sessions list from localStorage
        function loadSessionsList() {
            const sessionsList = document.getElementById('dtmc-sessions-list');
            const sessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            
            if (Object.keys(sessions).length === 0) {
                sessionsList.innerHTML = '<div class="dtmc-session-item"><div class="dtmc-session-item-description">No saved sessions found</div></div>';
                return;
            }
            
            // Sort sessions by timestamp (newest first)
            const sortedSessions = Object.values(sessions).sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            sessionsList.innerHTML = sortedSessions.map(session => {
                const date = new Date(session.timestamp).toLocaleString();
                const nodeCount = session.data.nodes.length;
                const connectionCount = session.data.connections.length;
                
                return `
                    <div class="dtmc-session-item" data-session-name="${session.name}">
                        <div class="dtmc-session-item-header">
                            <div class="dtmc-session-item-name">${session.name}</div>
                            <div class="dtmc-session-item-date">${date}</div>
                        </div>
                        ${session.description ? `<div class="dtmc-session-item-description">${session.description}</div>` : ''}
                        <div class="dtmc-session-item-stats">
                            <div class="dtmc-session-item-stat">
                                <span>üéØ</span>
                                <span>${nodeCount} tokens</span>
                            </div>
                            <div class="dtmc-session-item-stat">
                                <span>üîó</span>
                                <span>${connectionCount} connections</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Setup load modal event listeners
        function setupLoadModalEvents() {
            const modal = document.getElementById('dtmc-load-modal');
            const sessionsList = document.getElementById('dtmc-sessions-list');
            const loadBtn = document.getElementById('dtmc-load-confirm-btn');
            const cancelBtn = document.getElementById('dtmc-load-cancel-btn');
            let selectedSessionName = null;
            
            // Session item click
            sessionsList.onclick = (e) => {
                const sessionItem = e.target.closest('.dtmc-session-item');
                if (!sessionItem) return;
                
                // Remove previous selection
                document.querySelectorAll('.dtmc-session-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Add selection to clicked item
                sessionItem.classList.add('selected');
                selectedSessionName = sessionItem.dataset.sessionName;
                
                // Enable load button
                loadBtn.disabled = false;
            };
            
            // Load button click
            loadBtn.onclick = () => {
                if (selectedSessionName) {
                    loadSession(selectedSessionName);
                }
            };
            
            // Cancel button click
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Click outside modal to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Load session from localStorage
        function loadSession(sessionName) {
            const sessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            const sessionData = sessions[sessionName];
            
            if (!sessionData) {
                showNotification(`Session "${sessionName}" not found!`, 'error');
                return;
            }
            
            // Confirm before loading (will replace current setup)
            const confirmMessage = `Are you sure you want to load session "${sessionName}"?\n\nThis will replace your current setup with ${sessionData.data.nodes.length} tokens and ${sessionData.data.connections.length} connections.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                // Load session data
                nodes = sessionData.data.nodes;
                connections = sessionData.data.connections;
                tokens = sessionData.data.tokens;
                panOffset = sessionData.data.panOffset || { x: 0, y: 0 };
                zoomLevel = sessionData.data.zoomLevel || 1.0;
                
                // Fix connection references to point to the newly loaded nodes
                connections.forEach(connection => {
                    // Find the corresponding nodes in the newly loaded nodes array
                    const startNode = nodes.find(node => node.id === connection.startNode.id);
                    const endNode = nodes.find(node => node.id === connection.endNode.id);
                    
                    if (startNode && endNode) {
                        connection.startNode = startNode;
                        connection.endNode = endNode;
                    } else {
                        console.warn('Could not find node references for connection:', connection);
                    }
                });
                
                console.log(`Fixed ${connections.length} connection references`);
                
                // Clear selections
                selectedNode = null;
                selectedConnection = null;
                
                // Update UI
                renderSidebar();
                updateZoomDisplay();
                render();
                
                // Close modal
                document.getElementById('dtmc-load-modal').style.display = 'none';
                
                // Show success message
                showNotification(`Session "${sessionName}" loaded successfully!`, 'success');
                
                console.log(`Session "${sessionName}" loaded with ${nodes.length} nodes and ${connections.length} connections`);
                
            } catch (error) {
                console.error('Error loading session:', error);
                showNotification('Error loading session. The session data might be corrupted.', 'error');
            }
        }
        
        // Show notification message
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `dtmc-notification dtmc-notification-${type}`;
            notification.textContent = message;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Show notification
            setTimeout(() => {
                notification.classList.add('dtmc-notification-show');
            }, 100);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.remove('dtmc-notification-show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>
