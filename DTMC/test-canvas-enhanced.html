<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DTMC - Design Tokens Map Creator</title>
    
    <!-- Import Google Fonts - Sora -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Import Material Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <link rel="stylesheet" href="dtmc-styles.css">
</head>
<body>
    <div class="dtmc-container">
        <div class="dtmc-sidebar" id="dtmc-sidebar">
            <div class="dtmc-sidebar-header">
                <h2>Design Tokens</h2>
                <button class="dtmc-sidebar-collapse-btn" id="dtmc-sidebar-collapse-btn" title="Collapse sidebar">
                    <span class="material-icons">chevron_left</span>
                </button>
            </div>
            
            <div class="dtmc-token-types">
                <button class="dtmc-type-btn active" data-type="color">Color</button>
                <button class="dtmc-type-btn" data-type="spacing">Spacing</button>
                <button class="dtmc-type-btn" data-type="typography">Typography</button>
                <button class="dtmc-type-btn" data-type="number">Number</button>
                <button class="dtmc-type-btn" data-type="string">String</button>
                <button class="dtmc-type-btn" data-type="boolean">Boolean</button>
            </div>

            <div class="dtmc-layer-section dtmc-primitive-layers">
                <div class="dtmc-layer-header">
                    <div class="dtmc-layer-header-left">
                        <button class="dtmc-collapse-btn" data-layer="primitive" title="Collapse/Expand">
                            <span class="material-icons dtmc-collapse-icon">expand_more</span>
                        </button>
                        <span class="dtmc-token-type-indicator"></span>
                        <span class="dtmc-layer-title">Primitive</span>
                    </div>
                    <button class="dtmc-add-btn" data-layer="primitive">+</button>
                </div>
                <div class="dtmc-tokens-list" id="primitive-tokens"></div>
            </div>

            <div class="dtmc-layer-section dtmc-base-layers">
                <div class="dtmc-layer-header">
                    <div class="dtmc-layer-header-left">
                        <button class="dtmc-collapse-btn" data-layer="base" title="Collapse/Expand">
                            <span class="material-icons dtmc-collapse-icon">expand_more</span>
                        </button>
                        <span class="dtmc-token-type-indicator"></span>
                        <span class="dtmc-layer-title">Base</span>
                    </div>
                    <button class="dtmc-add-btn" data-layer="base">+</button>
                </div>
                <div class="dtmc-tokens-list" id="base-tokens"></div>
            </div>

            <div class="dtmc-layer-section dtmc-semantic-layers">
                <div class="dtmc-layer-header">
                    <div class="dtmc-layer-header-left">
                        <button class="dtmc-collapse-btn" data-layer="semantic" title="Collapse/Expand">
                            <span class="material-icons dtmc-collapse-icon">expand_more</span>
                        </button>
                        <span class="dtmc-token-type-indicator"></span>
                        <span class="dtmc-layer-title">Semantic</span>
                    </div>
                    <button class="dtmc-add-btn" data-layer="semantic">+</button>
                </div>
                <div class="dtmc-tokens-list" id="semantic-tokens"></div>
            </div>

            <div class="dtmc-layer-section dtmc-specific-layers">
                <div class="dtmc-layer-header">
                    <div class="dtmc-layer-header-left">
                        <button class="dtmc-collapse-btn" data-layer="specific" title="Collapse/Expand">
                            <span class="material-icons dtmc-collapse-icon">expand_more</span>
                        </button>
                        <span class="dtmc-token-type-indicator"></span>
                        <span class="dtmc-layer-title">Specific</span>
                    </div>
                    <button class="dtmc-add-btn" data-layer="specific">+</button>
                </div>
                <div class="dtmc-tokens-list" id="specific-tokens"></div>
            </div>
        </div>

        <!-- Sidebar Expand Button (visible when sidebar is collapsed) -->
        <button class="dtmc-sidebar-expand-btn" id="dtmc-sidebar-expand-btn" title="Expand sidebar" style="display: none;">
            <span class="material-icons">chevron_right</span>
        </button>

        <!-- Main Canvas Area -->
        <div class="dtmc-main">
            <div class="dtmc-controls">
                <!-- Always visible buttons -->
                <button id="dtmc-undo-btn" class="dtmc-btn secondary" title="Undo">
                    <span class="material-icons">undo</span>
                </button>
                <button id="dtmc-redo-btn" class="dtmc-btn secondary" title="Redo">
                    <span class="material-icons" style="font-size: 18px;"">redo</span>
                </button>
                <button id="dtmc-clear-btn" class="dtmc-btn secondary" title="Clear canvas">
                    <span class="material-icons">delete</span>
                </button>
                
                <!-- Menu button -->
                <div class="dtmc-menu-container">
                    <button id="dtmc-menu-btn" class="dtmc-btn secondary" title="More options">
                        <span class="material-icons">more_vert</span>
                    </button>
                    
                    <!-- Vertical menu -->
                    <div class="dtmc-vertical-menu" id="dtmc-vertical-menu">
                        <button class="dtmc-menu-item" id="dtmc-save-btn">
                            <span class="material-icons">save</span>
                            <span class="menu-text">Save setup</span>
                        </button>
                        <button class="dtmc-menu-item" id="dtmc-load-btn">
                            <span class="material-icons">folder_open</span>
                            <span class="menu-text">Load setup</span>
                        </button>
                        <button class="dtmc-menu-item" id="dtmc-export-btn">
                            <span class="material-icons">download</span>
                            <span class="menu-text">Export JSON</span>
                        </button>
                        <button class="dtmc-menu-item" id="dtmc-load-json-btn">
                            <span class="material-icons">file_open</span>
                            <span class="menu-text">Load JSON</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- File input for loading JSON -->
            <input type="file" id="dtmc-load-json-input" accept=".json" style="display: none;">
            <canvas id="dtmc-canvas"></canvas>
            
            <!-- Floating Context Menu -->
            <div id="dtmc-floating-menu" class="dtmc-floating-menu" style="display: none;">
                <button id="dtmc-delete-node-btn" class="dtmc-floating-btn" title="Delete from canvas">
                    <span class="material-icons">delete</span>
                </button>
                <button id="dtmc-delete-token-btn" class="dtmc-floating-btn" title="Delete token entirely">
                    <span class="material-icons">close</span>
                </button>
                <button id="dtmc-remove-from-group-btn" class="dtmc-floating-btn" title="Remove from group" style="display: none;">
                    <span class="material-icons">person_remove</span>
                </button>
            </div>
            
            <!-- Group Creation Menu (shows when multiple nodes selected) -->
            <div id="dtmc-group-menu" class="dtmc-group-menu" style="display: none;">
                <button id="dtmc-create-group-btn" class="dtmc-group-btn" title="Create New Group">
                    <span class="material-icons">group_work</span>
                    Create Group
                </button>
            </div>
            
            <!-- Group Management Menu (shows when right-clicking on groups) -->
            <div id="dtmc-group-management-menu" class="dtmc-group-menu" style="display: none;">
                <button id="dtmc-rename-group-btn" class="dtmc-group-btn" title="Rename Group">
                    <span class="material-icons">edit</span>
                    Rename
                </button>
                <button id="dtmc-ungroup-btn" class="dtmc-group-btn" title="Ungroup">
                    <span class="material-icons">group_off</span>
                    Ungroup
                </button>
            </div>
            
                        <!-- Group Header Controls are canvas-rendered, no HTML needed -->
            
            <!-- Group Rename Modal -->
            <div id="dtmc-rename-group-modal" class="dtmc-modal-overlay" style="display: none;">
                <div class="dtmc-modal">
                    <div class="dtmc-modal-header">
                        <h3 class="dtmc-modal-title">Rename Group</h3>
                        <p class="dtmc-modal-subtitle">Enter a new name for your group</p>
                    </div>
                    
                    <div class="dtmc-form-group">
                        <label for="group-new-name" class="dtmc-form-label">Group Name</label>
                        <input type="text" id="group-new-name" class="dtmc-form-input" placeholder="Enter new group name">
                    </div>
                    
                    <div class="dtmc-modal-footer">
                        <button id="dtmc-rename-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                        <button id="dtmc-rename-confirm-btn" class="dtmc-modal-btn create">Rename</button>
                    </div>
                </div>
            </div>
            
            <!-- Mini-map for navigation -->
            <div class="dtmc-minimap">
                <div class="dtmc-d-flex dtmc-align-center dtmc-justify-between dtmc-mb-md">
                    <div class="dtmc-zoom-controls">
                        <button id="dtmc-zoom-out-btn" class="dtmc-btn secondary">-</button>
                        <span id="dtmc-zoom-level">100%</span>
                        <button id="dtmc-zoom-in-btn" class="dtmc-btn secondary">+</button>
                        <button id="dtmc-reset-zoom-btn" class="dtmc-btn secondary">Reset</button>
                    </div>
                    <div class="dtmc-minimap-header">
                        <button id="dtmc-minimap-toggle" class="dtmc-btn secondary">Toggle</button>
                    </div>
                </div>
                <canvas id="dtmc-minimap-canvas" width="200" height="150"></canvas>
            </div>
            
            <!-- Show Mini-map Button (appears when mini-map is hidden) -->
            <button id="dtmc-minimap-show-btn" class="dtmc-minimap-show-btn" style="display: none;">
                <span class="material-icons dtmc-minimap-show-icon">map</span>
                <!-- <span class="dtmc-minimap-show-text">Show Map</span> -->
            </button>
        </div>
    </div>

    <!-- Enhanced Token Creation Modal -->
    <div id="dtmc-token-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <!-- <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Create New Token</h3>
                <p class="dtmc-modal-subtitle">Add a new token to your design system</p>
            </div> -->
            
            <!-- Token Name Input -->
            <div class="dtmc-form-group">
                <label for="token-name" class="dtmc-form-label">Token Name</label>
                <input type="text" id="token-name" class="dtmc-form-input" placeholder="e.g., primary-blue">
            </div>
            
            <!-- Dynamic Value Section -->
            <div id="token-value-section">
                <!-- Color Token Section -->
                <div id="color-token-section" class="dtmc-token-section">
                    <label class="dtmc-form-label">Choose a color:</label>
                    
                    <!-- Enhanced Color Picker -->
                    <div class="dtmc-color-picker-container">
                        <!-- Main Color Picker Square -->
                        <div class="dtmc-color-picker-main">
                            <div class="dtmc-color-square-container">
                                <canvas id="dtmc-color-square" width="300" height="300" class="dtmc-color-square"></canvas>
                                <div id="dtmc-color-square-indicator" class="dtmc-color-square-indicator"></div>
                            </div>
                            
                            <!-- Eyedropper Tool -->
                            <div class="dtmc-eyedropper-tool">
                                <button id="dtmc-eyedropper-btn" class="dtmc-eyedropper-btn" title="Pick color from screen">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                        <path d="M2 17l10 5 10-5"/>
                                        <path d="M2 12l10 5 10-5"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Hue Slider -->
                        <div class="dtmc-hue-slider-container">
                            <canvas id="dtmc-hue-slider" width="280" height="20" class="dtmc-hue-slider"></canvas>
                            <div id="dtmc-hue-indicator" class="dtmc-hue-indicator"></div>
                        </div>
                        
                        <!-- Opacity Slider -->
                        <div class="dtmc-opacity-slider-container">
                            <canvas id="dtmc-opacity-slider" width="280" height="20" class="dtmc-opacity-slider"></canvas>
                            <div id="dtmc-opacity-indicator" class="dtmc-opacity-indicator"></div>
                        </div>
                        
                        <!-- Color Input Controls -->
                        <div class="dtmc-color-controls">
                            <!-- Hex Input with Dropdown -->
                            <div class="dtmc-hex-input-group">
                                <div class="dtmc-hex-dropdown">
                                    <select id="dtmc-color-format" class="dtmc-format-select">
                                        <option value="hex">Hex</option>
                                        <option value="rgb">RGB</option>
                                        <option value="hsl">HSL</option>
                                    </select>
                                </div>
                                <input type="text" id="dtmc-hex-input" class="dtmc-hex-input" placeholder="#F5F5F5" maxlength="7">
                            </div>
                            
                            <!-- Opacity Input -->
                            <div class="dtmc-opacity-input-group">
                                <input type="number" id="dtmc-opacity-input" class="dtmc-opacity-input" min="0" max="100" value="100">
                                <span class="dtmc-opacity-percent">%</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Custom Color Input (Legacy) -->
                    <div class="dtmc-form-group">
                        <label for="token-value" class="dtmc-form-label">Custom Color (Hex)</label>
                        <input type="text" id="token-value" class="dtmc-form-input" placeholder="#4a90e2" maxlength="7">
                    </div>
                </div>
                
                <!-- Non-Primitive Layer Section -->
                <div id="reference-token-section" class="dtmc-token-section" style="display: none;">
                    <label class="dtmc-form-label">Select from existing tokens:</label>
                    <select id="token-reference-dropdown" class="dtmc-form-select">
                        <option value="">Select from existing tokens...</option>
                    </select>
                    <div class="dtmc-tip">
                        <span class="dtmc-tip-icon">üí°</span>
                        <span id="available-tokens-count">0 tokens available</span>
                    </div>
                    <div class="dtmc-form-group">
                        <label for="token-value-custom" class="dtmc-form-label">Or enter a custom value:</label>
                        <input type="text" id="token-value-custom" class="dtmc-form-input" placeholder="Enter custom value or select from dropdown above">
                    </div>
                </div>
                
                <!-- Simple Value Section -->
                <div id="simple-value-section" class="dtmc-token-section" style="display: none;">
                    <div class="dtmc-form-group">
                        <label for="token-value-simple" class="dtmc-form-label">Token Value</label>
                        <input type="text" id="token-value-simple" class="dtmc-form-input" placeholder="Enter value...">
                    </div>
                </div>
                
                <!-- Boolean Value Section -->
                <div id="boolean-value-section" class="dtmc-token-section" style="display: none;">
                    <div class="dtmc-form-group">
                        <label class="dtmc-form-label">Token Value</label>
                        <div class="dtmc-boolean-toggle">
                            <label class="dtmc-toggle-option">
                                <input type="radio" name="boolean-value" value="true" checked>
                                <span class="dtmc-toggle-label">True</span>
                            </label>
                            <label class="dtmc-toggle-option">
                                <input type="radio" name="boolean-value" value="false">
                                <span class="dtmc-toggle-label">False</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="dtmc-modal-footer">
                <button id="dtmc-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-create-btn" class="dtmc-modal-btn create">Create Token</button>
            </div>
        </div>
    </div>

    <!-- Drag Preview -->
    <div id="dtmc-drag-preview" class="dtmc-drag-preview" style="display: none;"></div>

    <!-- Save Session Modal -->
    <div id="dtmc-save-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Save Session</h3>
                <p class="dtmc-modal-subtitle">Save your current design token setup</p>
            </div>
            
            <div class="dtmc-form-group">
                <label class="dtmc-form-label">Save Options</label>
                <div class="dtmc-save-options">
                    <label class="dtmc-radio-option">
                        <input type="radio" name="save-option" value="new" checked>
                        <span class="dtmc-radio-label">Save as new session</span>
                    </label>
                    <label class="dtmc-radio-option">
                        <input type="radio" name="save-option" value="overwrite">
                        <span class="dtmc-radio-label">Overwrite existing session</span>
                    </label>
                </div>
            </div>
            
            <div class="dtmc-form-group" id="new-session-fields">
                <label for="session-name" class="dtmc-form-label">Session Name</label>
                <input type="text" id="session-name" class="dtmc-form-input" placeholder="e.g., My Design System v1">
            </div>
            
            <div class="dtmc-form-group" id="overwrite-session-fields" style="display: none;">
                <label class="dtmc-form-label">Select Session to Overwrite</label>
                <div id="dtmc-overwrite-sessions-list" class="dtmc-sessions-list">
                    <!-- Existing sessions will be populated here -->
                </div>
            </div>
            
            <div class="dtmc-form-group">
                <label for="session-description" class="dtmc-form-label">Description (optional)</label>
                <textarea id="session-description" class="dtmc-form-input" placeholder="Brief description of this session..." rows="3"></textarea>
            </div>
            
            <div class="dtmc-form-group">
                <label class="dtmc-form-label">Session Info</label>
                <div class="dtmc-session-info">
                    <div class="dtmc-session-stat">
                        <span class="dtmc-session-stat-label">Tokens:</span>
                        <span id="save-token-count" class="dtmc-session-stat-value">0</span>
                    </div>
                    <div class="dtmc-session-stat">
                        <span class="dtmc-session-stat-label">Connections:</span>
                        <span id="save-connection-count" class="dtmc-session-stat-value">0</span>
                    </div>
                    <div class="dtmc-session-stat">
                        <span class="dtmc-session-stat-label">Last Modified:</span>
                        <span id="save-last-modified" class="dtmc-session-stat-value">Now</span>
                    </div>
                </div>
            </div>
            
            <div class="dtmc-modal-footer">
                <button id="dtmc-save-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-save-confirm-btn" class="dtmc-modal-btn create">Save Session</button>
            </div>
        </div>
    </div>

    <!-- Load Session Modal -->
    <div id="dtmc-load-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Load Session</h3>
                <p class="dtmc-modal-subtitle">Load a previously saved session</p>
            </div>
            
            <div class="dtmc-form-group">
                <label class="dtmc-form-label">Saved Sessions</label>
                <div id="dtmc-sessions-list" class="dtmc-sessions-list">
                    <!-- Sessions will be populated here -->
                </div>
            </div>
            
            <div class="dtmc-form-group">
                <div class="dtmc-load-warning">
                    <span class="dtmc-warning-icon">‚ö†Ô∏è</span>
                    <span>Loading a session will replace your current setup. Make sure to save any unsaved changes.</span>
                </div>
            </div>
            
            <div class="dtmc-modal-footer">
                <button id="dtmc-load-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-load-confirm-btn" class="dtmc-modal-btn create" disabled>Load Selected Session</button>
            </div>
        </div>
    </div>

    <!-- Edit Token Modal -->
    <div id="dtmc-edit-token-modal" class="dtmc-modal-overlay" style="display: none;">
        <div class="dtmc-modal">
            <div class="dtmc-modal-header">
                <h3 class="dtmc-modal-title">Edit Token</h3>
                <p class="dtmc-modal-subtitle">Modify token name and value</p>
            </div>
            <div class="dtmc-modal-body">
                <div class="dtmc-form-group">
                    <label for="dtmc-edit-token-name" class="dtmc-form-label">Token Name</label>
                    <input type="text" id="dtmc-edit-token-name" class="dtmc-form-input" placeholder="Enter token name">
                </div>
                <div class="dtmc-form-group">
                    <label for="dtmc-edit-token-value" class="dtmc-form-label">Token Value</label>
                    <input type="text" id="dtmc-edit-token-value" class="dtmc-form-input" placeholder="Enter token value">
                </div>
                <div class="dtmc-form-group">
                    <label for="dtmc-edit-token-type" class="dtmc-form-label">Token Type</label>
                    <select id="dtmc-edit-token-type" class="dtmc-form-select">
                        <option value="color">Color</option>
                        <option value="spacing">Spacing</option>
                        <option value="typography">Typography</option>
                        <option value="number">Number</option>
                        <option value="string">String</option>
                        <option value="boolean">Boolean</option>
                    </select>
                </div>
            </div>
            <div class="dtmc-modal-footer">
                <button id="dtmc-edit-cancel-btn" class="dtmc-modal-btn cancel">Cancel</button>
                <button id="dtmc-edit-confirm-btn" class="dtmc-modal-btn create">Update Token</button>
            </div>
        </div>
    </div>

    <!-- Import DTMC Icon System -->
    <script src="dtmc-icons.js"></script>
    
    <!-- Import Fixed Functions -->
    <script src="fixed-functions.js"></script>

    <script>
        // Helper function to get CSS variables
        function getCSSVariable(variableName) {
            return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
        }
        
        // Helper function to parse CSS values
        function parseCSSValue(value) {
            if (value.includes('px')) {
                return parseFloat(value);
            } else if (value.includes('rgba')) {
                return value; // Return as is for rgba values
            } else if (value.includes('#')) {
                return value; // Return as is for hex colors
            } else {
                return parseFloat(value);
            }
        }
        
        // Canvas setup
        const canvas = document.getElementById('dtmc-canvas');
        const ctx = canvas.getContext('2d');
        
        // Polyfill for roundRect if not supported
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            };
        }
        
        // Constants
        const SOCKET_RADIUS = 9; // 18px diameter = 9px radius
        
        // Get bubble dimensions from CSS variables
        function getBubbleWidth() {
            return parseCSSValue(getCSSVariable('--dtmc-bubble-width'));
        }
        
        function getBubbleHeight() {
            return parseCSSValue(getCSSVariable('--dtmc-bubble-height'));
        }
        
        function getBubbleSpacingX() {
            return parseCSSValue(getCSSVariable('--dtmc-bubble-spacing-x'));
        }
        
        function getBubbleSpacingY() {
            return parseCSSValue(getCSSVariable('--dtmc-bubble-spacing-y'));
        }
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        
        // State
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let selectedConnection = null;
        let hoveredConnection = null;
        let hoverRenderTimeout = null;
        let selectedNodes = []; // Multi-selection array
        let isDragging = false;
        let isPanning = false;
        let panOffset = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let zoomLevel = 1.0;               // Current zoom level
        
        // Lasso selection variables
        let isLassoSelecting = false;
        let lassoStartPoint = { x: 0, y: 0 };
        let lassoCurrentPoint = { x: 0, y: 0 };
        let lassoPath = [];
        let isConnecting = false;
        let connectionStart = null;
        let startSocket = null;
        let endSocket = null;
        let selectedTokenType = 'color';
        let selectedLayer = null;
        let groups = []; // Array to store groups
        let tokens = {
            primitive: [],
            base: [],
            semantic: [],
            specific: []
        };
        
        // Token sub-groups within layers
        let tokenGroups = {
            primitive: {},
            base: {},
            semantic: {},
            specific: {}
        };
        
        // Selected tokens for grouping (Ctrl+click selection)
        let selectedSidebarTokens = [];
        let undoStack = [];
        let redoStack = [];
        let dragPreview = null;
        let draggedToken = null;
        let isDraggingGroup = false; // New: track if dragging a group
        let draggedGroup = null; // New: track which group is being dragged
        let isDraggingGroupedNode = false; // New: track if dragging a grouped node
        let draggedGroupedNode = null; // New: track which grouped node is being dragged

        // Initialize
        function init() {

            
            // Initialize drag preview
            dragPreview = document.getElementById('dtmc-drag-preview');
            if (!dragPreview) {
                console.error('‚ùå Drag preview element not found');
            }
            
            setupEventListeners();
            setupSidebar();
            loadSampleTokens();
            loadSampleNodes(); // Load sample nodes for testing
            
            // Migrate any existing connections to use socket positions
            migrateConnectionsToSockets();
            
            resizeCanvas();
            updateZoomDisplay();
            render();
            setupColorSwatchEvents();
            
            // Initialize icon system
            if (typeof window.initIconSystem === 'function') {
                window.initIconSystem();
            } else {
                console.error('‚ùå initIconSystem function not available');
            }
        }

        // Setup event listeners
        function setupEventListeners() {

            
            // Canvas events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Control buttons
            document.getElementById('dtmc-clear-btn').addEventListener('click', clearAll);
            document.getElementById('dtmc-undo-btn').addEventListener('click', () => {
                undo();
            });
            document.getElementById('dtmc-redo-btn').addEventListener('click', () => {
                redo();
            });
            
            // Vertical menu functionality
            const menuBtn = document.getElementById('dtmc-menu-btn');
            const verticalMenu = document.getElementById('dtmc-vertical-menu');
            
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                verticalMenu.classList.toggle('show');
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dtmc-menu-container')) {
                    verticalMenu.classList.remove('show');
                }
            });
            
            // Menu item event listeners
            document.getElementById('dtmc-save-btn').addEventListener('click', showSaveModal);
            document.getElementById('dtmc-load-btn').addEventListener('click', showLoadModal);
            document.getElementById('dtmc-export-btn').addEventListener('click', exportJSON);
            document.getElementById('dtmc-load-json-btn').addEventListener('click', () => {
                document.getElementById('dtmc-load-json-input').click();
            });
            
            // Debug: Check if menu items have their text spans and fix if needed
            setTimeout(() => {
                const menuItems = document.querySelectorAll('.dtmc-menu-item');
                menuItems.forEach((item, index) => {
                    const spans = item.querySelectorAll('span');
                    console.log(`Menu item ${index}:`, item.id, 'has', spans.length, 'spans');
                    spans.forEach((span, spanIndex) => {
                        console.log(`  Span ${spanIndex}:`, span.className, span.textContent);
                    });
                    
                    // If the item doesn't have a text span, add it
                    if (spans.length === 1) {
                        const textSpan = document.createElement('span');
                        textSpan.className = 'menu-text';
                        
                        // Set text based on button ID
                        switch(item.id) {
                            case 'dtmc-save-btn':
                                textSpan.textContent = 'Save setup';
                                break;
                            case 'dtmc-load-btn':
                                textSpan.textContent = 'Load setup';
                                break;
                            case 'dtmc-export-btn':
                                textSpan.textContent = 'Export JSON';
                                break;
                            case 'dtmc-load-json-btn':
                                textSpan.textContent = 'Load JSON';
                                break;
                        }
                        
                        item.appendChild(textSpan);
                        console.log(`Added text span to ${item.id}:`, textSpan.textContent);
                    }
                });
            }, 1000);
            
            // Zoom controls
            document.getElementById('dtmc-zoom-in-btn').addEventListener('click', () => zoomIn());
            document.getElementById('dtmc-zoom-out-btn').addEventListener('click', () => zoomOut());
            document.getElementById('dtmc-reset-zoom-btn').addEventListener('click', () => resetZoom());
            
            // File input change event
            document.getElementById('dtmc-load-json-input').addEventListener('change', handleJSONFileLoad);
            
            // Mini-map controls
            document.getElementById('dtmc-minimap-toggle').addEventListener('click', toggleMiniMap);
            
            // Show mini-map button
            document.getElementById('dtmc-minimap-show-btn').addEventListener('click', () => {
                const minimap = document.querySelector('.dtmc-minimap');
                const showBtn = document.getElementById('dtmc-minimap-show-btn');
                
                minimap.classList.remove('hidden');
                showBtn.style.display = 'none';
                renderMiniMap();
            });
            
            // Mini-map click navigation
            document.getElementById('dtmc-minimap-canvas').addEventListener('click', handleMiniMapClick);
            
            // Modal events
            document.getElementById('dtmc-cancel-btn').addEventListener('click', closeModal);
            document.getElementById('dtmc-create-btn').addEventListener('click', createToken);
            
            // Window events
            window.addEventListener('resize', resizeCanvas);
            

            
            // Keyboard events for connection deletion
            document.addEventListener('keydown', handleKeyDown);
            
            // Floating menu button events
            document.getElementById('dtmc-delete-node-btn').addEventListener('click', deleteNodeFromCanvas);
            document.getElementById('dtmc-delete-token-btn').addEventListener('click', deleteTokenEntirely);
            
            // Group menu button events
            document.getElementById('dtmc-create-group-btn').addEventListener('click', createGroup);
            
            // Remove from group button event
            document.getElementById('dtmc-remove-from-group-btn').addEventListener('click', () => {
                const menu = document.getElementById('dtmc-floating-menu');
                const nodeIndex = parseInt(menu.dataset.nodeId);
                if (nodeIndex >= 0 && nodeIndex < nodes.length) {
                    const node = nodes[nodeIndex];
                    if (node.groupId) {
                        removeNodeFromGroup(node, node.groupId);
                        hideFloatingMenu();
                    }
                }
            });
            
            // Group management menu button events
            document.getElementById('dtmc-rename-group-btn').addEventListener('click', () => {
                const menu = document.getElementById('dtmc-group-management-menu');
                const groupId = parseInt(menu.dataset.groupId);
                if (groupId) {
                    renameGroup(groupId);
                    hideGroupManagementMenu();
                }
            });
            
            document.getElementById('dtmc-ungroup-btn').addEventListener('click', () => {
                const menu = document.getElementById('dtmc-group-management-menu');
                const groupId = parseInt(menu.dataset.groupId);
                if (groupId) {
                    ungroupNodes(groupId);
                    hideGroupManagementMenu();
                }
            });
            
                        // Note: Group header buttons are canvas-rendered and handled in mouse events
            // No HTML event listeners needed for canvas buttons
            
            // Group rename modal event listeners
            document.getElementById('dtmc-rename-confirm-btn').addEventListener('click', () => {
                const modal = document.getElementById('dtmc-rename-group-modal');
                const nameInput = document.getElementById('group-new-name');
                const groupId = parseInt(modal.dataset.groupId);
                
                if (groupId && nameInput) {
                    const newName = nameInput.value.trim();
                    if (newName) {
                        const group = groups.find(g => g.id === groupId);
                        if (group) {
                            group.name = newName;
                            
                            // Recalculate group width if collapsed
                            if (group.isCollapsed) {
                                const centerX = group.bounds.x + group.bounds.width / 2;
                                const centerY = group.bounds.y + group.bounds.height / 2;
                                const newWidth = calculateMinimumGroupWidth(group);
                                
                                group.bounds = {
                                    x: centerX - newWidth / 2,
                                    y: centerY - group.bounds.height / 2,
                                    width: newWidth,
                                    height: group.bounds.height
                                };
                                
                                // Update header bounds
                                group.bounds.headerBounds = {
                                    x: group.bounds.x + 10,
                                    y: group.bounds.y - 15,
                                    width: group.bounds.width - 20,
                                    height: 30
                                };
                            }

                            render();
                        }
                    }
                }
                
                // Hide modal
                modal.style.display = 'none';
            });
            
            document.getElementById('dtmc-rename-cancel-btn').addEventListener('click', () => {
                const modal = document.getElementById('dtmc-rename-group-modal');
                modal.style.display = 'none';
            });
            
            // Close modal when clicking outside
            document.getElementById('dtmc-rename-group-modal').addEventListener('click', (e) => {
                if (e.target.id === 'dtmc-rename-group-modal') {
                    e.target.style.display = 'none';
                }
            });
            
            // Handle Enter key in rename input
            document.getElementById('group-new-name').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('dtmc-rename-confirm-btn').click();
                } else if (e.key === 'Escape') {
                    document.getElementById('dtmc-rename-cancel-btn').click();
                }
            });
            
            // Edit token modal event listeners
            document.getElementById('dtmc-edit-confirm-btn').addEventListener('click', () => {
                updateToken();
            });
            
            document.getElementById('dtmc-edit-cancel-btn').addEventListener('click', () => {
                const modal = document.getElementById('dtmc-edit-token-modal');
                modal.style.display = 'none';
            });
            
            // Close edit modal when clicking outside
            document.getElementById('dtmc-edit-token-modal').addEventListener('click', (e) => {
                if (e.target.id === 'dtmc-edit-token-modal') {
                    e.target.style.display = 'none';
                }
            });
            
            // Handle Enter key in edit token inputs
            document.getElementById('dtmc-edit-token-name').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('dtmc-edit-confirm-btn').click();
                } else if (e.key === 'Escape') {
                    document.getElementById('dtmc-edit-cancel-btn').click();
                }
            });
            
            document.getElementById('dtmc-edit-token-value').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('dtmc-edit-confirm-btn').click();
                } else if (e.key === 'Escape') {
                    document.getElementById('dtmc-edit-cancel-btn').click();
                }
            });
            
            // Right-click to show floating menu (with proper preventDefault)
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent browser context menu on canvas
                e.stopPropagation(); // Stop event bubbling
                
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
                const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
                
                const clickedNode = getNodeAtPoint(x, y);
                
                if (clickedNode) {
                    showFloatingMenu(x, y, clickedNode);
                } else {
                    hideFloatingMenu();
                }
            });
            
            // Hide floating menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#dtmc-floating-menu')) {
                    hideFloatingMenu();
                }
            });
            
            // Hide floating menu when right-clicking anywhere else
            document.addEventListener('contextmenu', (e) => {
                if (!e.target.closest('#dtmc-floating-menu')) {
                    hideFloatingMenu();
                }
                // Only prevent browser context menu when clicking on canvas
                if (e.target.closest('#dtmc-canvas')) {
                    e.preventDefault();
                }
            });
        }

        // Setup sidebar functionality
        function setupSidebar() {
            // Token type selection
            document.querySelectorAll('.dtmc-type-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.dtmc-type-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedTokenType = btn.dataset.type;

                });
            });

            // Add token buttons
            document.querySelectorAll('.dtmc-add-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedLayer = btn.dataset.layer;
                    openModal();
                });
            });

            // Collapse/expand buttons
            document.querySelectorAll('.dtmc-collapse-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const layer = btn.dataset.layer;
                    const tokensList = document.getElementById(`${layer}-tokens`);
                    const isCollapsed = tokensList.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        // Expand
                        tokensList.classList.remove('collapsed');
                        btn.classList.remove('collapsed');
                    } else {
                        // Collapse
                        tokensList.classList.add('collapsed');
                        btn.classList.add('collapsed');
                    }
                });
            });

            // Sidebar collapse/expand functionality
            const sidebar = document.getElementById('dtmc-sidebar');
            const sidebarCollapseBtn = document.getElementById('dtmc-sidebar-collapse-btn');
            const sidebarExpandBtn = document.getElementById('dtmc-sidebar-expand-btn');
            const mainContent = document.querySelector('.dtmc-main');

            sidebarCollapseBtn.addEventListener('click', () => {
                sidebar.classList.add('collapsed');
                sidebarExpandBtn.style.display = 'flex';
                mainContent.classList.add('sidebar-collapsed');
                
                // Trigger canvas resize after sidebar collapse
                setTimeout(() => {
                    resizeCanvas();
                }, 300); // Wait for CSS transition to complete
            });

            sidebarExpandBtn.addEventListener('click', () => {
                sidebar.classList.remove('collapsed');
                sidebarExpandBtn.style.display = 'none';
                mainContent.classList.remove('sidebar-collapsed');
                
                // Trigger canvas resize after sidebar expand
                setTimeout(() => {
                    resizeCanvas();
                }, 300); // Wait for CSS transition to complete
            });
        }

        // Load sample tokens
        function loadSampleTokens() {
            tokens.primitive = [
                { name: 'primary-blue', value: '#4a90e2', type: 'color' }
            ];
            
            tokens.base = [
                { name: 'color-brand', value: '{primitive.primary-blue}', type: 'color' }
            ];
            
            tokens.semantic = [
                { name: 'button-bg', value: '{base.color-brand}', type: 'color' }
            ];
            
            tokens.specific = [
                { name: 'button-primary', value: '{semantic.button-bg}', type: 'color' }
            ];
            
            renderSidebar();
        }
        
        // Load sample nodes for testing groups
        function loadSampleNodes() {
            // Create some sample nodes
            const sampleNodes = [
                {
                    id: Date.now() + 1,
                    x: 100,
                    y: 100,
                    name: 'primary-blue',
                    value: '#4a90e2',
                    type: 'color',
                    layer: 'primitive',
                    originalValue: '#4a90e2'
                },
                {
                    id: Date.now() + 2,
                    x: 350,
                    y: 100,
                    name: 'secondary-purple',
                    value: '#805ad5',
                    type: 'color',
                    layer: 'primitive',
                    originalValue: '#805ad5'
                },
                {
                    id: Date.now() + 3,
                    x: 600,
                    y: 100,
                    name: 'font-size-base',
                    value: '16px',
                    type: 'number',
                    layer: 'primitive',
                    originalValue: '16px'
                }
            ];
            
            nodes.push(...sampleNodes);
            
            // Create automatic connections for any nodes with references
            createAllAutomaticConnections();
            
            // Create a sample group
            setTimeout(() => {
                // Select the first two nodes
                selectedNodes = [nodes[0], nodes[1]];
                createGroup();

            }, 1000);
        }

        // Render sidebar
        function renderSidebar() {
            Object.keys(tokens).forEach(layer => {
                const container = document.getElementById(`${layer}-tokens`);
                container.innerHTML = '';
                
                // Add group creation button at the top if multiple tokens are selected
                if (selectedSidebarTokens.length >= 2 && selectedSidebarTokens.every(t => t.layer === layer)) {
                    const groupButton = createGroupCreationButton(layer);
                    container.appendChild(groupButton);
                }
                
                // Get tokens that are not in any group
                const ungroupedTokens = tokens[layer].filter(token => !token.groupId);
                
                // Render ungrouped tokens first
                ungroupedTokens.forEach(token => {
                    const tokenElement = createTokenElement(token, layer);
                    
                    // Check if this token is selected and add the selected class
                    const isSelected = selectedSidebarTokens.some(t => 
                        t.token.name === token.name && t.layer === layer
                    );
                    if (isSelected) {
                        tokenElement.classList.add('selected');
                    }
                    
                    container.appendChild(tokenElement);
                });
                
                // Render token groups
                Object.keys(tokenGroups[layer]).forEach(groupName => {
                    const group = tokenGroups[layer][groupName];
                    const groupElement = createTokenGroupElement(group, layer);
                    container.appendChild(groupElement);
                });
            });
        }

        // Create token element for sidebar
        function createTokenElement(token, layer) {
            const div = document.createElement('div');
            div.className = 'dtmc-token-item';
            div.draggable = true;
            div.dataset.tokenName = token.name;
            div.dataset.tokenValue = token.value;
            div.dataset.tokenType = token.type;
            div.dataset.tokenLayer = layer;
            
            div.innerHTML = `
                <div class="dtmc-token-content">
                    <div class="dtmc-token-drag-handle" title="Drag to reorder">
                        <span class="material-icons">drag_indicator</span>
                    </div>
                    <div class="dtmc-token-info">
                        <div class="dtmc-token-name">${token.name}</div>
                        <div class="dtmc-token-value">
                            ${layer === 'primitive' && token.type === 'color' && !token.value.startsWith('{') && !token.value.startsWith('$') ? 
                                `<span class="dtmc-color-preview" style="background-color: ${token.value}"></span>` : 
                                ''
                            }
                            ${layer === 'primitive' && token.type === 'boolean' ? 
                                `<span class="dtmc-boolean-indicator ${token.value === 'true' ? 'dtmc-boolean-true' : 'dtmc-boolean-false'}">${token.value === 'true' ? '‚úì' : '‚úó'}</span>` : 
                                ''
                            }
                            ${token.value}
                        </div>
                    </div>
                    <div class="dtmc-token-actions">
                        <button class="dtmc-token-action-btn dtmc-rename-btn" title="Edit token">
                            <span class="material-icons">edit</span>
                        </button>
                        <button class="dtmc-token-action-btn dtmc-delete-btn" title="Delete token">
                            <span class="material-icons">delete</span>
                        </button>
                    </div>
                </div>
            `;
            
            div.addEventListener('dragstart', (e) => {

                
                // Add dragging class
                div.classList.add('dragging');
                
                // Check if drag started from drag handle (for reordering) or from token content (for canvas)
                // More robust detection of drag handle
                const isDragHandle = e.target.closest('.dtmc-token-drag-handle') !== null ||
                                   e.target.classList.contains('dtmc-token-drag-handle') ||
                                   (e.target.classList.contains('material-icons') && 
                                    e.target.textContent.trim() === 'drag_indicator') ||
                                   e.target.getAttribute('data-is-drag-handle') === 'true' ||
                                   e.target.closest('[data-is-drag-handle="true"]') !== null;
                

                
                if (isDragHandle) {
                    // For reordering within sidebar
                    draggedToken = { ...token, layer, isReorder: true };
                    e.dataTransfer.setData('text/plain', JSON.stringify(draggedToken));
                    e.dataTransfer.effectAllowed = 'move';

                } else {
                    // For dragging to canvas
                    draggedToken = { ...token, layer, isReorder: false };
                    e.dataTransfer.setData('text/plain', JSON.stringify(draggedToken));
                    
                    if (dragPreview) {
                        dragPreview.style.display = 'block';
                        dragPreview.textContent = `${token.name} (${token.value})`;
                        e.dataTransfer.setDragImage(dragPreview, 0, 0);
                    } else {
                        console.warn('‚ö†Ô∏è Drag preview not available, using default drag image');
                    }
                    

                }
            });
            
            div.addEventListener('dragend', () => {
                if (dragPreview) {
                    dragPreview.style.display = 'none';
                }
            });
            
            // Add drag and drop for reordering within sidebar
            div.addEventListener('dragover', (e) => {
                e.preventDefault();
                

                
                // Check if we have a dragged token and it's a reorder operation
                if (draggedToken && draggedToken.isReorder && draggedToken.layer === div.dataset.tokenLayer) {
                    e.dataTransfer.dropEffect = 'move';

                    
                    // Add visual feedback for drop zones
                    const afterElement = getDragAfterElement(div.parentNode, e.clientY);
                    const dragging = document.querySelector('.dragging');
                    
                    if (afterElement == null) {
                        div.parentNode.appendChild(dragging);
                    } else {
                        div.parentNode.insertBefore(dragging, afterElement);
                    }
                }
            });
            
            div.addEventListener('dragenter', (e) => {
                e.preventDefault();
                
                // Check if this is a reorder operation
                if (draggedToken && draggedToken.isReorder && draggedToken.layer === div.dataset.tokenLayer) {
                    div.classList.add('drag-over');
                }
            });
            
            div.addEventListener('dragleave', () => {
                div.classList.remove('drag-over');
            });
            
            div.addEventListener('drop', (e) => {
                e.preventDefault();
                div.classList.remove('drag-over');
                

                
                // Check if we have a dragged token and it's a reorder operation
                if (draggedToken && draggedToken.isReorder && draggedToken.layer === div.dataset.tokenLayer) {
                    const targetTokenName = div.dataset.tokenName;

                    reorderTokens(draggedToken, targetTokenName, div.dataset.tokenLayer);
                } else {

                }
            });
            
            div.addEventListener('dragend', () => {
                div.classList.remove('dragging');
                // Remove all drag-over classes
                document.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });

            });
            
            // Add event listeners for action buttons
            const renameBtn = div.querySelector('.dtmc-rename-btn');
            const deleteBtn = div.querySelector('.dtmc-delete-btn');
            const dragHandle = div.querySelector('.dtmc-token-drag-handle');
            
            // Check if drag handle was found
            if (!dragHandle) {
                console.error('‚ùå Drag handle not found for token:', token.name);
                return div;
            }
            
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                editToken(token, layer);
            });
            
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteToken(token, layer);
            });
            
            // Add data attribute to identify drag handle
            dragHandle.dataset.isDragHandle = 'true';
            
            // Ensure drag handle can initiate drag events
            dragHandle.style.cursor = 'grab';
            dragHandle.draggable = true;
            

            
            // Add specific event listeners for drag handle
            dragHandle.addEventListener('dragstart', (e) => {

                
                // Set the reorder flag directly
                draggedToken = { ...token, layer, isReorder: true };
                e.dataTransfer.setData('text/plain', JSON.stringify(draggedToken));
                e.dataTransfer.effectAllowed = 'move';
                
                // Add dragging class
                div.classList.add('dragging');
                

                
                // Stop propagation to prevent parent from handling this
                e.stopPropagation();
            });
            
            dragHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();

            });
            
            dragHandle.addEventListener('click', (e) => {
                e.stopPropagation();

            });
            
            dragHandle.addEventListener('dragend', (e) => {
                div.classList.remove('dragging');

            });
            
            // Add click handler for token selection
            div.addEventListener('click', (e) => {
                // Don't trigger selection if clicking on action buttons
                if (e.target.closest('.dtmc-token-action-btn')) {
                    return;
                }
                
                // Don't trigger selection if clicking on drag handle
                if (e.target.closest('.dtmc-token-drag-handle')) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                // Handle Ctrl+click for multi-selection
                if (e.ctrlKey || e.metaKey) {
                    const tokenInfo = { token, layer };
                    const existingIndex = selectedSidebarTokens.findIndex(t => 
                        t.token.name === token.name && t.layer === layer
                    );
                    
                    if (existingIndex >= 0) {
                        // Remove from selection
                        selectedSidebarTokens.splice(existingIndex, 1);
                        div.classList.remove('selected');

                    } else {
                        // Add to selection
                        selectedSidebarTokens.push(tokenInfo);
                        div.classList.add('selected');

                    }
                } else {
                    // Single selection - clear others and select this one
                    clearSidebarTokenSelection();
                    selectedSidebarTokens = [{ token, layer }];
                    div.classList.add('selected');

                }
                
                // Re-render to show group creation button if applicable
                renderSidebar();
                

            });
            
            return div;
        }

        // Clear sidebar token selection
        function clearSidebarTokenSelection() {
            // Remove visual selection from all currently selected tokens
            selectedSidebarTokens.forEach(({ token, layer }) => {
                const tokenElement = document.querySelector(`[data-token-name="${token.name}"][data-token-layer="${layer}"]`);
                if (tokenElement) {
                    tokenElement.classList.remove('selected');
                }
            });
            selectedSidebarTokens = [];
        }

        // Create token group element
        function createTokenGroupElement(group, layer) {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'dtmc-token-group';
            groupDiv.dataset.groupName = group.name;
            groupDiv.dataset.layer = layer;
            
            const isCollapsed = group.isCollapsed || false;
            
            groupDiv.innerHTML = `
                <div class="dtmc-token-group-header">
                    <button class="dtmc-token-group-toggle" data-group="${group.name}" data-layer="${layer}">
                        <span class="material-icons dtmc-token-group-icon">${isCollapsed ? 'chevron_right' : 'expand_more'}</span>
                    </button>
                    <span class="dtmc-token-group-name">${group.name}</span>
                    <span class="dtmc-token-group-count">(${group.tokens.length})</span>
                    <div class="dtmc-token-group-actions">
                        <button class="dtmc-token-group-rename" title="Rename group">
                            <span class="material-icons">edit</span>
                        </button>
                        <button class="dtmc-token-group-ungroup" title="Ungroup tokens">
                            <span class="material-icons">group_off</span>
                        </button>
                    </div>
                </div>
                <div class="dtmc-token-group-content ${isCollapsed ? 'collapsed' : ''}">
                    ${group.tokens.map(token => {
                        const tokenElement = createTokenElement(token, layer);
                        
                        // Check if this token is selected and add the selected class
                        const isSelected = selectedSidebarTokens.some(t => 
                            t.token.name === token.name && t.layer === layer
                        );
                        if (isSelected) {
                            tokenElement.classList.add('selected');
                        }
                        
                        return tokenElement.outerHTML;
                    }).join('')}
                </div>
            `;
            
            // Add event listeners
            const toggleBtn = groupDiv.querySelector('.dtmc-token-group-toggle');
            const renameBtn = groupDiv.querySelector('.dtmc-token-group-rename');
            const ungroupBtn = groupDiv.querySelector('.dtmc-token-group-ungroup');
            
            toggleBtn.addEventListener('click', () => toggleTokenGroup(group.name, layer));
            renameBtn.addEventListener('click', () => renameTokenGroup(group.name, layer));
            ungroupBtn.addEventListener('click', () => ungroupTokens(group.name, layer));
            
            return groupDiv;
        }

        // Create group creation button
        function createGroupCreationButton(layer) {
            const buttonDiv = document.createElement('div');
            buttonDiv.className = 'dtmc-create-group-button';
            
            buttonDiv.innerHTML = `
                <button class="dtmc-create-group-btn" data-layer="${layer}">
                    <span class="material-icons">group_work</span>
                    Create Group (${selectedSidebarTokens.length} tokens)
                </button>
            `;
            
            const button = buttonDiv.querySelector('.dtmc-create-group-btn');
            button.addEventListener('click', () => createTokenGroup(layer));
            
            return buttonDiv;
        }

        // Toggle token group collapse/expand
        function toggleTokenGroup(groupName, layer) {
            const group = tokenGroups[layer][groupName];
            if (group) {
                group.isCollapsed = !group.isCollapsed;
                renderSidebar();
            }
        }

        // Rename token group
        function renameTokenGroup(groupName, layer) {
            const newName = prompt('Enter new group name:', groupName);
            if (newName && newName !== groupName && newName.trim()) {
                const group = tokenGroups[layer][groupName];
                if (group) {
                    // Update group name
                    group.name = newName.trim();
                    
                    // Update token group reference
                    delete tokenGroups[layer][groupName];
                    tokenGroups[layer][newName.trim()] = group;
                    
                    renderSidebar();

                }
            }
        }

        // Ungroup tokens
        function ungroupTokens(groupName, layer) {
            const group = tokenGroups[layer][groupName];
            if (group) {
                // Remove groupId from all tokens in the group
                group.tokens.forEach(token => {
                    delete token.groupId;
                });
                
                // Remove the group
                delete tokenGroups[layer][groupName];
                
                renderSidebar();

            }
        }

        // Create token group
        function createTokenGroup(layer) {
            if (selectedSidebarTokens.length < 2) {
                alert('Please select at least 2 tokens to create a group.');
                return;
            }
            
            // Check if all selected tokens are from the same layer
            if (!selectedSidebarTokens.every(t => t.layer === layer)) {
                alert('All selected tokens must be from the same layer.');
                return;
            }
            
            const groupName = prompt('Enter group name:', 'New Group');
            if (!groupName || !groupName.trim()) {
                return;
            }
            
            // Check if group name already exists
            if (tokenGroups[layer][groupName.trim()]) {
                alert('A group with this name already exists in this layer.');
                return;
            }
            
            // Create the group
            const groupId = Date.now();
            const group = {
                id: groupId,
                name: groupName.trim(),
                tokens: selectedSidebarTokens.map(t => t.token),
                isCollapsed: false
            };
            
            // Add groupId to tokens
            group.tokens.forEach(token => {
                token.groupId = groupId;
            });
            
            // Add group to tokenGroups
            tokenGroups[layer][groupName.trim()] = group;
            
            // Clear selection
            clearSidebarTokenSelection();
            
            // Re-render
            renderSidebar();
            

        }

        // Helper function to get the element after which to insert the dragged element
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.dtmc-token-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Function to reorder tokens within the same layer
        function reorderTokens(draggedToken, targetTokenName, layer) {

            
            const layerTokens = tokens[layer];
            const draggedIndex = layerTokens.findIndex(t => t.name === draggedToken.name);
            const targetIndex = layerTokens.findIndex(t => t.name === targetTokenName);
            

            
            if (draggedIndex === -1 || targetIndex === -1) {
                console.error('Token not found for reordering', { draggedIndex, targetIndex });
                return;
            }
            
            // Don't reorder if it's the same position
            if (draggedIndex === targetIndex) {

                return;
            }
            
            // Remove the dragged token from its current position
            const [movedToken] = layerTokens.splice(draggedIndex, 1);
            
            // Insert it at the new position
            layerTokens.splice(targetIndex, 0, movedToken);
            
            // Save state and re-render
            saveState();
            renderSidebar();
            render();
            

        }

        // Edit token function - opens modal for editing name and value
        function editToken(token, layer) {
            const modal = document.getElementById('dtmc-edit-token-modal');
            const nameInput = document.getElementById('dtmc-edit-token-name');
            const valueInput = document.getElementById('dtmc-edit-token-value');
            const typeSelect = document.getElementById('dtmc-edit-token-type');
            
            if (!modal || !nameInput || !valueInput || !typeSelect) {
                console.error('Edit token modal elements not found');
                return;
            }
            
            // Populate modal with current token data
            nameInput.value = token.name;
            valueInput.value = token.value;
            typeSelect.value = token.type;
            
            // Store current token and layer for later use
            modal.dataset.tokenId = token.id;
            modal.dataset.layer = layer;
            modal.dataset.oldName = token.name;
            
            // Show modal
            modal.style.display = 'flex';
            
            // Focus on name input
            nameInput.focus();
            nameInput.select();
            

        }
        
        // Update token function - called when user confirms edit
        function updateToken() {
            const modal = document.getElementById('dtmc-edit-token-modal');
            const nameInput = document.getElementById('dtmc-edit-token-name');
            const valueInput = document.getElementById('dtmc-edit-token-value');
            const typeSelect = document.getElementById('dtmc-edit-token-type');
            
            if (!modal || !nameInput || !valueInput || !typeSelect) {
                console.error('Edit token modal elements not found');
                return;
            }
            
            const newName = nameInput.value.trim();
            const newValue = valueInput.value.trim();
            const newType = typeSelect.value;
            const layer = modal.dataset.layer;
            const oldName = modal.dataset.oldName;
            
            // Validate inputs
            if (!newName || !newValue) {
                alert('Please enter both name and value for the token.');
                return;
            }
            
            // Check if name already exists in the same layer (and it's different from current name)
            if (newName !== oldName) {
                const existingToken = tokens[layer].find(t => t.name === newName);
                if (existingToken) {
                    alert(`Token name "${newName}" already exists in the ${layer} layer.`);
                    return;
                }
            }
            
            // Find the token to update
            const tokenIndex = tokens[layer].findIndex(t => t.name === oldName);
            if (tokenIndex === -1) {
                console.error('Token not found for update');
                return;
            }
            
            // Update token
            const token = tokens[layer][tokenIndex];
            token.name = newName;
            token.value = newValue;
            token.type = newType;
            
            // Update any nodes that reference this token
            nodes.forEach(node => {
                if (node.layer === layer && node.name === oldName) {
                    node.name = newName;
                }
            });
            
            // Update any connections that reference this token
            connections.forEach(connection => {
                if (connection.fromNode === oldName && connection.fromLayer === layer) {
                    connection.fromNode = newName;
                }
                if (connection.toNode === oldName && connection.toLayer === layer) {
                    connection.toNode = newName;
                }
            });
            
            // Update canvas nodes with the new token value
            updateNodesWithToken(token, layer);
            
            // Save state and re-render
            saveState();
            renderSidebar();
            render();
            
            // Close modal
            modal.style.display = 'none';
            

        }

        // Delete token function
        function deleteToken(token, layer) {
            const confirmDelete = confirm(`Are you sure you want to delete the token "${token.name}" from the ${layer} layer?\n\nThis will also remove any nodes and connections associated with this token.`);
            
            if (confirmDelete) {
                // Remove token from tokens array
                tokens[layer] = tokens[layer].filter(t => t.name !== token.name);
                
                // Remove any nodes with this token
                const nodesToRemove = nodes.filter(node => node.layer === layer && node.name === token.name);
                nodesToRemove.forEach(node => {
                    // Remove connections involving this node
                    connections = connections.filter(conn => 
                        !(conn.fromNode === node.name && conn.fromLayer === layer) &&
                        !(conn.toNode === node.name && conn.toLayer === layer)
                    );
                });
                nodes = nodes.filter(node => !(node.layer === layer && node.name === token.name));
                
                // Save state and re-render
                saveState();
                renderSidebar();
                render();
                

            }
        }

        // Open modal for token creation
        function openModal() {

            
            const modal = document.getElementById('dtmc-token-modal');
            const modalTitle = document.querySelector('.dtmc-modal-title');
            
            if (!modal) {
                console.error('‚ùå Modal not found!');
                return;
            }
            
            if (!modalTitle) {
                console.error('‚ùå Modal title not found!');
                return;
            }
            

            
            // Update modal title
            modalTitle.textContent = `Create New ${selectedTokenType.charAt(0).toUpperCase() + selectedTokenType.slice(1)} Token`;
            
            // Show appropriate value section
            showAppropriateValueSection();
            
            // Populate reference dropdown if needed
            if (selectedLayer !== 'primitive') {
                populateReferenceDropdown();
            }
            
            modal.style.display = 'flex';
            
            // Initialize color picker if this is a color token
            if (selectedTokenType === 'color' && selectedLayer === 'primitive') {
                // Use setTimeout to ensure DOM elements are rendered
                setTimeout(() => {
                    initColorPicker();
                }, 100);
            }
            

        }

        // Show appropriate value section based on token type and layer
        function showAppropriateValueSection() {
            const colorSection = document.getElementById('color-token-section');
            const referenceSection = document.getElementById('reference-token-section');
            const simpleSection = document.getElementById('simple-value-section');
            const booleanSection = document.getElementById('boolean-value-section');
            
            // Hide all sections first
            colorSection.style.display = 'none';
            referenceSection.style.display = 'none';
            simpleSection.style.display = 'none';
            booleanSection.style.display = 'none';
            
            if (selectedTokenType === 'color' && selectedLayer === 'primitive') {
                // Color tokens in primitive layer show color palette
                colorSection.style.display = 'block';
            } else if (selectedTokenType === 'boolean' && selectedLayer === 'primitive') {
                // Boolean tokens in primitive layer show true/false toggle
                booleanSection.style.display = 'block';
            } else if (selectedLayer !== 'primitive') {
                // Non-primitive layers show reference dropdown
                referenceSection.style.display = 'block';
            } else {
                // Other token types show simple input
                simpleSection.style.display = 'block';
            }
        }

        // Populate reference dropdown with available tokens
        function populateReferenceDropdown() {
            const dropdown = document.getElementById('token-reference-dropdown');
            const countSpan = document.getElementById('available-tokens-count');
            
            // Clear existing options
            dropdown.innerHTML = '<option value="">Select from existing tokens...</option>';
            
            let availableTokens = [];
            
            // Collect tokens from all layers except the current one
            Object.keys(tokens).forEach(layer => {
                if (layer !== selectedLayer) {
                    tokens[layer].forEach(token => {
                        availableTokens.push({
                            layer: layer,
                            name: token.name,
                            value: token.value,
                            displayText: `${layer}.${token.name} (${token.value})`
                        });
                    });
                }
            });
            
            // Add options to dropdown
            availableTokens.forEach(token => {
                const option = document.createElement('option');
                option.value = JSON.stringify(token);
                option.textContent = token.displayText;
                dropdown.appendChild(option);
            });
            
            // Update count
            countSpan.textContent = `${availableTokens.length} tokens available`;
            
            // Add change event listener
            dropdown.onchange = function() {
                const selectedValue = this.value;
                if (selectedValue) {
                    const tokenData = JSON.parse(selectedValue);
                    document.getElementById('token-value-custom').value = `{${tokenData.layer}.${tokenData.name}}`;
                }
            };
        }

        // Setup color swatch click events
        function setupColorSwatchEvents() {
            const colorSwatches = document.querySelectorAll('.dtmc-color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', function() {
                    // Remove selected class from all swatches
                    colorSwatches.forEach(s => s.classList.remove('selected'));
                    // Add selected class to clicked swatch
                    this.classList.add('selected');
                    // Update the token value input
                    const colorValue = this.getAttribute('data-color');
                    document.getElementById('token-value').value = colorValue;
                    
                    // Update color picker with selected color
                    updateColorPickerFromHex(colorValue);
                });
            });
        }

        // Initialize enhanced color picker
        function initColorPicker() {
            const colorSquareCanvas = document.getElementById('dtmc-color-square');
            const hueSliderCanvas = document.getElementById('dtmc-hue-slider');
            const opacitySliderCanvas = document.getElementById('dtmc-opacity-slider');
            
            if (colorSquareCanvas && hueSliderCanvas && opacitySliderCanvas) {
                renderColorSquare(colorSquareCanvas);
                renderHueSlider(hueSliderCanvas);
                renderOpacitySlider(opacitySliderCanvas);
                
                // Add event listeners
                setupColorSquareEvents(colorSquareCanvas);
                setupHueSliderEvents(hueSliderCanvas);
                setupOpacitySliderEvents(opacitySliderCanvas);
                setupColorInputEvents();
                setupEyedropperEvents();
                
                // Set initial color
                updateColorPickerFromHex('#F5F5F5');
            }
        }

        // Render main color square (saturation/lightness picker)
        function renderColorSquare(canvas) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Get current hue
            const currentHue = window.currentHue || 0;
            
            // Create saturation gradient (left to right)
            for (let x = 0; x < width; x++) {
                const saturation = (x / width) * 100;
                
                // Create lightness gradient (top to bottom)
                for (let y = 0; y < height; y++) {
                    const lightness = 100 - (y / height) * 100;
                    
                    ctx.fillStyle = `hsl(${currentHue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        // Render saturation/lightness picker
        function renderSLPicker(canvas, baseColor) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Extract hue from base color
            const tempDiv = document.createElement('div');
            tempDiv.style.color = baseColor;
            document.body.appendChild(tempDiv);
            const computedColor = getComputedStyle(tempDiv).color;
            document.body.removeChild(tempDiv);
            
            // Parse RGB to get HSL
            const rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]) / 255;
                const g = parseInt(rgbMatch[2]) / 255;
                const b = parseInt(rgbMatch[3]) / 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                
                // Draw saturation/lightness grid
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        const saturation = x / width;
                        const lightness = 1 - (y / height);
                        
                        if (lightness <= 0 || lightness >= 1) {
                            ctx.fillStyle = '#000000';
                        } else {
                            const color = `hsl(${h * 360}, ${saturation * 100}%, ${lightness * 100}%)`;
                            ctx.fillStyle = color;
                        }
                        
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        // Render hue slider
        function renderHueSlider(canvas) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Create hue gradient
            for (let x = 0; x < width; x++) {
                const hue = (x / width) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(x, 0, 1, height);
            }
        }

        // Render opacity slider with checkerboard background
        function renderOpacitySlider(canvas) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw checkerboard pattern
            const checkerSize = 8;
            for (let x = 0; x < width; x += checkerSize) {
                for (let y = 0; y < height; y += checkerSize) {
                    const isEven = ((x / checkerSize) + (y / checkerSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? '#ffffff' : '#cccccc';
                    ctx.fillRect(x, y, checkerSize, checkerSize);
                }
            }
            
            // Draw opacity gradient
            const currentColor = window.currentColor || '#F5F5F5';
            for (let x = 0; x < width; x++) {
                const opacity = x / width;
                ctx.fillStyle = currentColor + Math.round(opacity * 255).toString(16).padStart(2, '0');
                ctx.fillRect(x, 0, 1, height);
            }
        }

        // Setup color square events
        function setupColorSquareEvents(canvas) {
            canvas.addEventListener('mousedown', handleColorSquareMouseDown);
            canvas.addEventListener('mousemove', handleColorSquareMouseMove);
            canvas.addEventListener('mouseup', handleColorSquareMouseUp);
            
            let isDragging = false;
            
            function handleColorSquareMouseDown(e) {
                isDragging = true;
                updateColorFromSquare(e);
            }
            
            function handleColorSquareMouseMove(e) {
                if (isDragging) {
                    updateColorFromSquare(e);
                }
            }
            
            function handleColorSquareMouseUp() {
                isDragging = false;
            }
            
            function updateColorFromSquare(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const saturation = Math.round((x / canvas.width) * 100);
                const lightness = Math.round(100 - (y / canvas.height) * 100);
                const hue = window.currentHue || 0;
                
                updateCurrentColor(hue, saturation, lightness);
            }
        }

        // Setup hue slider events
        function setupHueSliderEvents(canvas) {
            canvas.addEventListener('mousedown', handleHueSliderMouseDown);
            canvas.addEventListener('mousemove', handleHueSliderMouseMove);
            canvas.addEventListener('mouseup', handleHueSliderMouseUp);
            
            let isDragging = false;
            
            function handleHueSliderMouseDown(e) {
                isDragging = true;
                updateHueFromSlider(e);
            }
            
            function handleHueSliderMouseMove(e) {
                if (isDragging) {
                    updateHueFromSlider(e);
                }
            }
            
            function handleHueSliderMouseUp() {
                isDragging = false;
            }
            
            function updateHueFromSlider(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                const hue = Math.round((x / canvas.width) * 360);
                window.currentHue = hue;
                
                // Re-render color square with new hue
                const colorSquare = document.getElementById('dtmc-color-square');
                renderColorSquare(colorSquare);
                
                // Update current color with new hue
                const currentS = window.currentSaturation || 0;
                const currentL = window.currentLightness || 100;
                updateCurrentColor(hue, currentS, currentL);
            }
        }

        // Setup opacity slider events
        function setupOpacitySliderEvents(canvas) {
            canvas.addEventListener('mousedown', handleOpacitySliderMouseDown);
            canvas.addEventListener('mousemove', handleOpacitySliderMouseMove);
            canvas.addEventListener('mouseup', handleOpacitySliderMouseUp);
            
            let isDragging = false;
            
            function handleOpacitySliderMouseDown(e) {
                isDragging = true;
                updateOpacityFromSlider(e);
            }
            
            function handleOpacitySliderMouseMove(e) {
                if (isDragging) {
                    updateOpacityFromSlider(e);
                }
            }
            
            function handleOpacitySliderMouseUp() {
                isDragging = false;
            }
            
            function updateOpacityFromSlider(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                const opacity = Math.round((x / canvas.width) * 100);
                window.currentOpacity = opacity;
                
                // Update opacity input
                document.getElementById('dtmc-opacity-input').value = opacity;
                
                // Update main token value with opacity
                updateTokenValueWithOpacity();
            }
        }

        // Setup color input events
        function setupColorInputEvents() {
            // Hex input
            document.getElementById('dtmc-hex-input').addEventListener('input', function() {
                const hex = this.value;
                if (isValidHex(hex)) {
                    updateColorPickerFromHex(hex, false);
                }
            });
            
            // Opacity input
            document.getElementById('dtmc-opacity-input').addEventListener('input', function() {
                const opacity = parseInt(this.value) || 100;
                window.currentOpacity = opacity;
                updateTokenValueWithOpacity();
            });
            
            // Format dropdown
            document.getElementById('dtmc-color-format').addEventListener('change', function() {
                const format = this.value;
                updateInputFormat(format);
            });
        }

        // Setup eyedropper events
        function setupEyedropperEvents() {
            document.getElementById('dtmc-eyedropper-btn').addEventListener('click', function() {
                // Note: Eyedropper API is limited in web browsers
                // This is a placeholder for future implementation

            });
        }

        // Update current color from hue, saturation, lightness
        function updateCurrentColor(h, s, l) {
            const hex = hslToHex(h, s, l);
            const rgb = hexToRGB(hex);
            
            // Store current values
            window.currentHue = h;
            window.currentSaturation = s;
            window.currentLightness = l;
            window.currentColor = hex;
            
            // Update input fields
            document.getElementById('dtmc-hex-input').value = hex;
            
            // Update main token value input
            updateTokenValueWithOpacity();
            
            // Update picker indicators
            updateColorSquareIndicator(s, l);
            updateHueIndicator(h);
            updateOpacityIndicator(window.currentOpacity || 100);
            
            // Re-render opacity slider with new color
            const opacitySlider = document.getElementById('dtmc-opacity-slider');
            renderOpacitySlider(opacitySlider);
        }

        // Update token value with current opacity
        function updateTokenValueWithOpacity() {
            const tokenValueInput = document.getElementById('token-value');
            if (tokenValueInput && window.currentColor) {
                const opacity = window.currentOpacity || 100;
                if (opacity < 100) {
                    // Convert to rgba format
                    const rgb = hexToRGB(window.currentColor);
                    tokenValueInput.value = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity / 100})`;
                } else {
                    tokenValueInput.value = window.currentColor;
                }
            }
        }

        // Update input format based on dropdown selection
        function updateInputFormat(format) {
            const hexInput = document.getElementById('dtmc-hex-input');
            if (!window.currentColor) return;
            
            const rgb = hexToRGB(window.currentColor);
            const hsl = hexToHSL(window.currentColor);
            
            switch (format) {
                case 'hex':
                    hexInput.value = window.currentColor;
                    break;
                case 'rgb':
                    hexInput.value = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    break;
                case 'hsl':
                    hexInput.value = `hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`;
                    break;
            }
        }

        // Update color picker from hex value
        function updateColorPickerFromHex(hex, updateInputs = true) {
            if (!isValidHex(hex)) return;
            
            const rgb = hexToRGB(hex);
            const hsl = hexToHSL(hex);
            
            // Store current values
            window.currentHue = Math.round(hsl.h);
            window.currentSaturation = Math.round(hsl.s);
            window.currentLightness = Math.round(hsl.l);
            window.currentColor = hex;
            
            if (updateInputs) {
                // Update input fields
                document.getElementById('dtmc-hex-input').value = hex;
            }
            
            // Update main token value input
            updateTokenValueWithOpacity();
            
            // Update picker indicators
            updateColorSquareIndicator(hsl.s, hsl.l);
            updateHueIndicator(hsl.h);
            updateOpacityIndicator(window.currentOpacity || 100);
            
            // Re-render color square and opacity slider
            const colorSquare = document.getElementById('dtmc-color-square');
            const opacitySlider = document.getElementById('dtmc-opacity-slider');
            renderColorSquare(colorSquare);
            renderOpacitySlider(opacitySlider);
        }

        // Update color square indicator position
        function updateColorSquareIndicator(saturation, lightness) {
            const indicator = document.getElementById('dtmc-color-square-indicator');
            if (!indicator) return;
            
            const canvas = document.getElementById('dtmc-color-square');
            const x = (saturation / 100) * canvas.width;
            const y = (1 - lightness / 100) * canvas.height;
            
            indicator.style.left = x + 'px';
            indicator.style.top = y + 'px';
        }

        // Update hue indicator position
        function updateHueIndicator(hue) {
            const indicator = document.getElementById('dtmc-hue-indicator');
            if (!indicator) return;
            
            const canvas = document.getElementById('dtmc-hue-slider');
            const x = (hue / 360) * canvas.width;
            
            indicator.style.left = x + 'px';
        }

        // Update opacity indicator position
        function updateOpacityIndicator(opacity) {
            const indicator = document.getElementById('dtmc-opacity-indicator');
            if (!indicator) return;
            
            const canvas = document.getElementById('dtmc-opacity-slider');
            const x = (opacity / 100) * canvas.width;
            
            indicator.style.left = x + 'px';
        }

        // Utility functions
        function isValidHex(hex) {
            return /^#[0-9A-F]{6}$/i.test(hex);
        }

        function hexToRGB(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function hexToHSL(hex) {
            const rgb = hexToRGB(hex);
            const r = rgb.r / 255;
            const g = rgb.g / 255;
            const b = rgb.b / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return {
                h: h * 360,
                s: s * 100,
                l: l * 100
            };
        }

        function hslToHex(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            let r = 0, g = 0, b = 0;
            
            // Fixed hue ranges for proper color conversion
            if (0 <= h && h < 1/6) {
                r = c; g = x; b = 0;
            } else if (1/6 <= h && h < 2/6) {
                r = x; g = c; b = 0;
            } else if (2/6 <= h && h < 3/6) {
                r = 0; g = c; b = x;
            } else if (3/6 <= h && h < 4/6) {
                r = 0; g = x; b = c;
            } else if (4/6 <= h && h < 5/6) {
                r = x; g = 0; b = c;
            } else if (5/6 <= h && h < 1) {
                r = c; g = 0; b = x;
            }
            
            const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
            const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
            const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
            
            return '#' + rHex + gHex + bHex;
        }

        function closeModal() {
            const modal = document.getElementById('dtmc-token-modal');
            modal.style.display = 'none';
            
            // Clear all inputs
            document.getElementById('token-name').value = '';
            document.getElementById('token-value').value = '';
            document.getElementById('token-value-custom').value = '';
            document.getElementById('token-value-simple').value = '';
            
            // Reset color picker inputs if they exist
            const hexInput = document.getElementById('dtmc-hex-input');
            if (hexInput) {
                hexInput.value = '';
                document.getElementById('dtmc-opacity-input').value = '100';
                document.getElementById('dtmc-color-format').value = 'hex';
            }
            
            // Reset color swatch selection
            document.querySelectorAll('.dtmc-color-swatch').forEach(s => s.classList.remove('selected'));
            
            // Reset dropdown
            document.getElementById('token-reference-dropdown').selectedIndex = 0;
        }

        // Create token
        function createToken() {
            const name = document.getElementById('token-name').value.trim();
            let value = '';
            
            // Get value from appropriate input field
            if (selectedTokenType === 'color' && selectedLayer === 'primitive') {
                value = document.getElementById('token-value').value.trim();
            } else if (selectedTokenType === 'boolean' && selectedLayer === 'primitive') {
                // Get boolean value from radio buttons
                const selectedBoolean = document.querySelector('input[name="boolean-value"]:checked');
                value = selectedBoolean ? selectedBoolean.value : 'true';
            } else if (selectedLayer !== 'primitive') {
                value = document.getElementById('token-value-custom').value.trim();
            } else {
                value = document.getElementById('token-value-simple').value.trim();
            }
            
            if (!name || !value) {
                alert('Please fill in both name and value');
                return;
            }
            
            const newToken = {
                name,
                value,
                type: selectedTokenType
            };
            
            tokens[selectedLayer].push(newToken);
            renderSidebar();
            closeModal();
            
            // Update any existing nodes with this token
            updateNodesWithToken(newToken, selectedLayer);
            

        }

        // Mouse event handlers
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Check if clicking on a socket
            const socketInfo = getSocketAtPoint(x, y);
            if (socketInfo) {
                isConnecting = true;
                connectionStart = socketInfo.node;
                startSocket = socketInfo.socket;
                return;
            }
            
            // Check if clicking on group buttons first
            const clickedGroupButton = getGroupButtonAtPoint(x, y);
            if (clickedGroupButton) {

                
                if (clickedGroupButton.button === 'rename') {
                    renameGroup(clickedGroupButton.group.id);
                    return;
                } else if (clickedGroupButton.button === 'ungroup') {
                    ungroupNodes(clickedGroupButton.group.id);
                    return;
                }
            }
            
            // Check if clicking on the group arrow (for collapse/expand)
            for (const group of groups) {
                if (isPointOnGroupArrow(x, y, group)) {

                    
                    // Disable right-click context menu on group arrow
                    if (e.button === 2) {
                        e.preventDefault();
                        return;
                    }
                    
                    // Left-click on arrow toggles collapse/expand
                    toggleGroupCollapse(group.id);
                    return;
                }
            }
            
            // Check if clicking on the group header draggable area (between arrow and buttons)
            for (const group of groups) {
                if (isPointInGroupHeaderDraggableArea(x, y, group)) {
    
                    
                    // Disable right-click context menu on group header
                    if (e.button === 2) {
                        e.preventDefault();
                        return;
                    }
                    
                    // Left-click starts group dragging
                    isDraggingGroup = true;
                    draggedGroup = group;
                    lastMousePos = { x: e.clientX, y: e.clientY };
                    
                    // Reset individual node dragging states
                    isDragging = false;
                    selectedNode = null;
                    isDraggingGroupedNode = false;
                    draggedGroupedNode = null;
                    
                    return;
                }
            }
            
            // Note: Group body is no longer draggable - only header dragging is allowed
            // This allows full interaction with bubbles and connections within the group
            
            // Check if clicking on a connection line
            const clickedConnection = getConnectionAtPoint(x, y);
            if (clickedConnection) {

                
                // Select the connection (will be drawn in red)
                selectedConnection = clickedConnection;
                selectedNode = null; // Deselect any selected node
                selectedNodes = []; // Clear multi-selection
                
                // Re-render to show selected connection
                render();
                return;
            }
            
            // Check if clicking on a node
            const clickedNode = getNodeAtPoint(x, y);
            if (clickedNode) {
                // Check if this node is in a collapsed group
                if (clickedNode.groupId) {
                    const group = groups.find(g => g.id === clickedNode.groupId);
                    if (group && group.isCollapsed) {
                        // Don't allow interaction with nodes in collapsed groups

                        return;
                    }
                }
                
                // Handle multi-selection with Ctrl key
                if (e.ctrlKey || e.metaKey) {
                    if (selectedNodes.includes(clickedNode)) {
                        // Remove from selection if already selected
                        const index = selectedNodes.indexOf(clickedNode);
                        selectedNodes.splice(index, 1);
                        selectedNode = null;
                    } else {
                        // Add to selection
                        selectedNodes.push(clickedNode);
                        selectedNode = clickedNode;
                    }

                } else {
                    // Single selection (clear multi-selection)
                    selectedNodes = [clickedNode];
                    selectedNode = clickedNode;
                }
                
                selectedConnection = null; // Deselect any selected connection
                
                // Only start dragging if it's a left click (not right click for context menu)
                if (e.button === 0) { // Left click
                    isDragging = true;
                    
                    // Reset group dragging states when starting to drag a node
                    isDraggingGroup = false;
                    draggedGroup = null;
                    
                    lastMousePos = { x: e.clientX, y: e.clientY };
                    // Hide floating menu when starting to drag
                    hideFloatingMenu();
                }
                
                render(); // Re-render to show selection
                return;
            }
            
            // Start lasso selection if Alt key is held and clicking on empty space
            if (e.altKey && e.button === 0) {
                isLassoSelecting = true;
                lassoStartPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                lassoCurrentPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                lassoPath = [{ x: e.clientX - rect.left, y: e.clientY - rect.top }]; // Keep for compatibility
                
                // Clear current selection
                selectedNode = null;
                selectedConnection = null;
                selectedNodes = [];
                

                return;
            }
            
            // Deselect if clicking on empty space
            if (selectedNode || selectedConnection || selectedNodes.length > 0) {
                selectedNode = null;
                selectedConnection = null;
                selectedNodes = [];
                render();
            }
            
            // Hide floating menu when clicking on empty canvas
            hideFloatingMenu();
            
            // Start panning
            isPanning = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
            
            // Hide floating menu when starting to pan
            hideFloatingMenu();
        }

        function handleMouseMove(e) {
            if (isConnecting) {
                // Handle connection preview
                render();
                drawConnectionPreview(e);
                return;
            }
            
            if (isDraggingGroup && draggedGroup) {
                // Handle group dragging
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                // Move the entire group and all its nodes
                draggedGroup.bounds.x += deltaX;
                draggedGroup.bounds.y += deltaY;
                
                // Move all nodes in the group
                draggedGroup.nodes.forEach(node => {
                    node.x += deltaX;
                    node.y += deltaY;
                });
                
                // Update connection socket positions based on new node positions
                updateConnectionSockets();
                
                // Update header bounds
                if (draggedGroup.bounds.headerBounds) {
                    draggedGroup.bounds.headerBounds.x += deltaX;
                    draggedGroup.bounds.headerBounds.y += deltaY;
                }
                
                // Update button bounds
                if (draggedGroup.renameButtonBounds) {
                    draggedGroup.renameButtonBounds.x += deltaX;
                    draggedGroup.renameButtonBounds.y += deltaY;
                }
                if (draggedGroup.ungroupButtonBounds) {
                    draggedGroup.ungroupButtonBounds.x += deltaX;
                    draggedGroup.ungroupButtonBounds.y += deltaY;
                }
                
                lastMousePos = { x: e.clientX, y: e.clientY };

                
                render();
                return;
            }
            
            if (isDragging && selectedNode) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                // Check if this is a grouped node
                if (selectedNode.groupId) {
                    const group = groups.find(g => g.id === selectedNode.groupId);
                    if (group && !group.isCollapsed) {
                        // Start dragging grouped node (only if group is expanded)
                        isDraggingGroupedNode = true;
                        draggedGroupedNode = selectedNode;
                        draggedGroup = group;
                    }
                }
                
                // Move only the selected node (not the entire group)
                selectedNode.x += deltaX;
                selectedNode.y += deltaY;
                
                // Update connection socket positions based on new node positions
                updateConnectionSockets();
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                
                // Ensure connections are updated when node moves

                
                // If dragging a grouped node, update group bounds
                if (isDraggingGroupedNode && draggedGroup) {
                    updateGroupBounds(draggedGroup.id);
                }
                
                render();
                return;
            }
            
            // Handle lasso selection
            if (isLassoSelecting) {
                const rect = canvas.getBoundingClientRect();
                lassoCurrentPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                render();
                return;
            }
            
            if (isPanning) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                panOffset.x += deltaX;
                panOffset.y += deltaY;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                render();
            }
            
            // Update cursor based on what's under the mouse
            updateCursor(e);
            
            // Always update lastMousePos for hover effects
            lastMousePos = { x: e.clientX, y: e.clientY };
            
            // Re-render to show hover effects
            render();
        }

        function handleMouseUp(e) {
            if (isConnecting) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
                const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
                
                const socketInfo = getSocketAtPoint(x, y);
                if (socketInfo && socketInfo.node !== connectionStart) {
                    // Validate connection (output to input only)
                    if ((startSocket === 'right' || startSocket === 'bottom') && 
                        (socketInfo.socket === 'top' || socketInfo.socket === 'left')) {
                        
                        // Store original value if not already stored
                        if (!socketInfo.node.originalValue) {
                            socketInfo.node.originalValue = socketInfo.node.value;

                        }
                        
                        const connection = {
                            startNode: connectionStart,
                            endNode: socketInfo.node,
                            startSocket: startSocket,
                            endSocket: socketInfo.socket
                        };
                        
                        connections.push(connection);
                        saveState();
                        
                        // Update the target node's value to show the reference path to the source
                        const referencePath = `{${connectionStart.layer}.${connectionStart.name}}`;
                        socketInfo.node.value = referencePath;
                        socketInfo.node.currentValue = referencePath;
                        
                        // Also update the corresponding token in the tokens object for sidebar and JSON export
                        const targetLayer = socketInfo.node.layer;
                        const targetToken = tokens[targetLayer]?.find(t => t.name === socketInfo.node.name);
                        if (targetToken) {
                            targetToken.value = referencePath;

                        }
                        
                        // Re-render sidebar to show updated values
                        renderSidebar();
                        

                    } else {
                        console.warn('Invalid connection: Can only connect output to input sockets');
                    }
                }
                
                isConnecting = false;
                connectionStart = null;
                startSocket = null;
                render();
                return;
            }
            
            // Complete lasso selection
            if (isLassoSelecting) {
                // Select nodes within the rectangle
                selectNodesInLasso();
                
                // Reset lasso selection
                isLassoSelecting = false;
                lassoPath = [];
                lassoStartPoint = { x: 0, y: 0 };
                lassoCurrentPoint = { x: 0, y: 0 };
                
                render();
                return;
            }
            
            // Reset all dragging states
            isDragging = false;
            isDraggingGroup = false;
            isDraggingGroupedNode = false;
            isPanning = false;
            selectedNode = null;
            
            // Save state if group was dragged
            if (draggedGroup) {
                saveState();

            }
            
            draggedGroup = null;
            draggedGroupedNode = null;
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate zoom factor
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * zoomFactor));
            
            if (newZoom !== zoomLevel) {
                // Calculate zoom center relative to canvas
                const zoomCenterX = (mouseX - panOffset.x) / zoomLevel;
                const zoomCenterY = (mouseY - panOffset.y) / zoomLevel;
                
                // Update zoom level
                zoomLevel = newZoom;
                
                // Adjust pan offset to zoom towards mouse position
                panOffset.x = mouseX - zoomCenterX * zoomLevel;
                panOffset.y = mouseY - zoomCenterY * zoomLevel;
                
                // Re-render with new zoom
                render();
            }
        }

        // Helper functions
        function getNodeAtPoint(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (x >= node.x && x <= node.x + getBubbleWidth() &&
                    y >= node.y && y <= node.y + getBubbleHeight()) {
                    return node;
                }
            }
            return null;
        }
        
        // Get group at specific point
        function getGroupAtPoint(x, y) {
            for (let i = groups.length - 1; i >= 0; i--) {
                const group = groups[i];
                if (group.clickBounds && 
                    x >= group.clickBounds.x && x <= group.clickBounds.x + group.clickBounds.width &&
                    y >= group.clickBounds.y && y <= group.clickBounds.y + group.clickBounds.height) {
                    return group;
                }
            }
            return null;
        }
        
        // Get group header at specific point
        function getGroupHeaderAtPoint(x, y) {
            for (let i = groups.length - 1; i >= 0; i--) {
                const group = groups[i];
                if (group.bounds && group.bounds.headerBounds && 
                    x >= group.bounds.headerBounds.x && x <= group.bounds.headerBounds.x + group.bounds.headerBounds.width &&
                    y >= group.bounds.headerBounds.y && y <= group.bounds.headerBounds.y + group.bounds.headerBounds.height) {
                    return { group, isHeader: true };
                }
            }
            return null;
        }
        
        // Check if clicking specifically on the arrow area (for collapse/expand)
        function isPointOnGroupArrow(x, y, group) {
            if (!group.bounds || !group.bounds.headerBounds) return false;
            
            const header = group.bounds.headerBounds;
            
            // Check if point is within header bounds
            if (x < header.x || x > header.x + header.width ||
                y < header.y || y > header.y + header.height) {
                return false;
            }
            
            // Arrow area is the left side, first 30px
            return x < header.x + 30;
        }
        
        // Get group button at specific point
        function getGroupButtonAtPoint(x, y) {
            for (let i = groups.length - 1; i >= 0; i--) {
                const group = groups[i];
                
                // Check rename button
                if (group.renameButtonBounds && 
                    x >= group.renameButtonBounds.x && x <= group.renameButtonBounds.x + group.renameButtonBounds.width &&
                    y >= group.renameButtonBounds.y && y <= group.renameButtonBounds.y + group.renameButtonBounds.height) {
                    return { group, button: 'rename' };
                }
                
                // Check ungroup button
                if (group.ungroupButtonBounds && 
                    x >= group.ungroupButtonBounds.x && x <= group.ungroupButtonBounds.x + group.ungroupButtonBounds.width &&
                    y >= group.ungroupButtonBounds.y && y <= group.ungroupButtonBounds.y + group.ungroupButtonBounds.height) {
                    return { group, button: 'ungroup' };
                }
            }
            return null;
        }
        
        // Check if a point is within the group header's draggable area (between arrow and buttons)
        function isPointInGroupHeaderDraggableArea(x, y, group) {
            if (!group.bounds || !group.bounds.headerBounds) return false;
            
            const header = group.bounds.headerBounds;
            
            // Check if point is within header bounds
            if (x < header.x || x > header.x + header.width ||
                y < header.y || y > header.y + header.height) {
                return false;
            }
            
            // Exclude arrow area (left side, first 30px)
            if (x < header.x + 30) {
                return false;
            }
            
            // Exclude button areas (right side, last 60px)
            if (x > header.x + header.width - 100) {
                return false;
            }
            
            return true;
        }

        function getSocketAtPoint(x, y) {
            for (const node of nodes) {
                const sockets = [
                    { x: node.x + getBubbleWidth() / 2, y: node.y, type: 'input', socket: 'top' },
                    { x: node.x, y: node.y + getBubbleHeight() / 2, type: 'input', socket: 'left' },
                    { x: node.x + getBubbleWidth(), y: node.y + getBubbleHeight() / 2, type: 'output', socket: 'right' },
                    { x: node.x + getBubbleWidth() / 2, y: node.y + getBubbleHeight(), type: 'output', socket: 'bottom' }
                ];
                
                for (const socket of sockets) {
                    const distance = Math.sqrt((x - socket.x) ** 2 + (y - socket.y) ** 2);
                    if (distance <= SOCKET_RADIUS) {
                        return { node, ...socket };
                    }
                }
            }
            return null;
        }

        // Check if a point is near a connection line
        function getConnectionAtPoint(x, y) {
            const CLICK_TOLERANCE = 8; // How close to the line you need to click
            
            // First check individual connections
            for (const connection of connections) {
                const startGroup = groups.find(g => g.id === connection.startNode.groupId);
                const endGroup = groups.find(g => g.id === connection.endNode.groupId);
                
                // Skip connections within the same collapsed group
                if (startGroup && endGroup && startGroup.id === endGroup.id && startGroup.isCollapsed) {
                    continue;
                }
                
                // Skip if either node is in a collapsed group (will be handled by consolidated connections)
                if ((startGroup && startGroup.isCollapsed) || (endGroup && endGroup.isCollapsed)) {
                    continue;
                }
                
                const startPoint = getSocketPosition(connection.startNode, connection.startSocket);
                const endPoint = getSocketPosition(connection.endNode, connection.endSocket);
                
                // Calculate distance from point to line segment
                const distance = distanceToLineSegment(x, y, startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                
                if (distance <= CLICK_TOLERANCE) {
                    return connection;
                }
            }
            
            // Then check consolidated connections
            return getConsolidatedConnectionAtPoint(x, y);
        }
        
        // Check for clicks on consolidated connections
        function getConsolidatedConnectionAtPoint(x, y) {
            const CLICK_TOLERANCE = 8;
            
            // Group connections by their source and target (considering collapsed groups)
            const connectionGroups = new Map();
            
            connections.forEach((connection) => {
                const startGroup = groups.find(g => g.id === connection.startNode.groupId);
                const endGroup = groups.find(g => g.id === connection.endNode.groupId);
                
                // Skip connections within the same collapsed group
                if (startGroup && endGroup && startGroup.id === endGroup.id && startGroup.isCollapsed) {
                    return;
                }
                
                // Only consider connections involving collapsed groups
                if (!((startGroup && startGroup.isCollapsed) || (endGroup && endGroup.isCollapsed))) {
                    return;
                }
                
                // Determine source and target identifiers
                let sourceId, targetId;
                
                if (startGroup && startGroup.isCollapsed) {
                    sourceId = `group_${startGroup.id}`;
                } else {
                    sourceId = `node_${connection.startNode.id}`;
                }
                
                if (endGroup && endGroup.isCollapsed) {
                    targetId = `group_${endGroup.id}`;
                } else {
                    targetId = `node_${connection.endNode.id}`;
                }
                
                const connectionKey = `${sourceId}_${targetId}`;
                
                if (!connectionGroups.has(connectionKey)) {
                    connectionGroups.set(connectionKey, {
                        connections: [],
                        sourceGroup: startGroup,
                        targetGroup: endGroup,
                        sourceNode: connection.startNode,
                        targetNode: connection.endNode,
                        startSocket: connection.startSocket,
                        endSocket: connection.endSocket
                    });
                }
                
                connectionGroups.get(connectionKey).connections.push(connection);
            });
            
            // Check each consolidated connection
            for (const [key, group] of connectionGroups) {
                if (group.connections.length > 1) {
                    // Calculate consolidated connection path
                    const { sourceGroup, targetGroup, sourceNode, targetNode, startSocket, endSocket } = group;
                    
                    let startPoint, endPoint;
                    
                    if (sourceGroup && sourceGroup.isCollapsed) {
                        startPoint = {
                            x: sourceGroup.bounds.x + sourceGroup.bounds.width / 2,
                            y: sourceGroup.bounds.y + sourceGroup.bounds.height / 2
                        };
                    } else {
                        startPoint = getSocketPosition(sourceNode, startSocket);
                    }
                    
                    if (targetGroup && targetGroup.isCollapsed) {
                        endPoint = {
                            x: targetGroup.bounds.x + targetGroup.bounds.width / 2,
                            y: targetGroup.bounds.y + targetGroup.bounds.height / 2
                        };
                    } else {
                        endPoint = getSocketPosition(targetNode, endSocket);
                    }
                    
                    // Calculate distance from point to curved line (approximate with straight line for simplicity)
                    const distance = distanceToLineSegment(x, y, startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                    
                    if (distance <= CLICK_TOLERANCE) {
                        // Return the first connection as a representative
                        return group.connections[0];
                    }
                }
            }
            
            return null;
        }

        // Calculate distance from point to line segment
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) {
                // Point is at start point
                return Math.sqrt(A * A + B * B);
            }
            
            let param = dot / lenSq;
            
            if (param < 0) {
                // Closest point is start point
                return Math.sqrt(A * A + B * B);
            } else if (param > 1) {
                // Closest point is end point
                return Math.sqrt((px - x2) * (px - x2) + (py - y2) * (py - y2));
            } else {
                // Closest point is on the line segment
                const x = x1 + param * C;
                const y = y1 + param * D;
                return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y));
            }
        }

        function drawConnectionPreview(e) {
            if (!connectionStart) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Get CSS variables for connection preview styling
            const connectionPreviewColor = getCSSVariable('--dtmc-connection-preview-color');
            const connectionWidth = parseCSSValue(getCSSVariable('--dtmc-connection-width'));
            
            ctx.strokeStyle = connectionPreviewColor;
            ctx.lineWidth = connectionWidth;
            ctx.setLineDash([5, 5]);
            
            const startPoint = getSocketPosition(connectionStart, startSocket);
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function getSocketPosition(node, socket) {
            switch (socket) {
                case 'top': return { x: node.x + getBubbleWidth() / 2, y: node.y };
                case 'left': return { x: node.x, y: node.y + getBubbleHeight() / 2 };
                case 'right': return { x: node.x + getBubbleWidth(), y: node.y + getBubbleHeight() / 2 };
                case 'bottom': return { x: node.x + getBubbleWidth() / 2, y: node.y + getBubbleHeight() };
                default: return { x: node.x + getBubbleWidth() / 2, y: node.y + getBubbleHeight() / 2 };
            }
        }

        // ===== GROUP MANAGEMENT FUNCTIONS =====
        
        // Create a new group from selected nodes
        function createGroup() {
            if (selectedNodes.length < 2) {

                return;
            }
            
            const groupId = Date.now();
            const group = {
                id: groupId,
                name: `Group ${groups.length + 1}`,
                nodes: [...selectedNodes],
                bounds: calculateGroupBounds(selectedNodes),
                isCollapsed: false, // New: collapse/expand state
                originalBounds: null, // New: store original bounds for restore
                headerBounds: null // New: store header bounds for click detection
            };
            
            // Add group reference to nodes
            selectedNodes.forEach(node => {
                node.groupId = groupId;
            });
            
            // Ensure group.nodes contains references to the actual node objects
            group.nodes = selectedNodes;
            
            groups.push(group);

            
            // Clear selection and re-render
            selectedNodes = [];
            selectedNode = null;
            render();
        }
        
        // Calculate bounds for a group
        function calculateGroupBounds(nodes) {
            if (nodes.length === 0) return null;
            
            let minX = Math.min(...nodes.map(n => n.x));
            let maxX = Math.max(...nodes.map(n => n.x + getBubbleWidth()));
            let minY = Math.min(...nodes.map(n => n.y));
            let maxY = Math.max(...nodes.map(n => n.y + getBubbleHeight()));
            
            const bounds = {
                x: minX - 20, // Padding
                y: minY - 20,
                width: maxX - minX + 40,
                height: maxY - minY + 40
            };
            
            // Calculate header bounds (overlapping the top of the group)
            bounds.headerBounds = {
                x: bounds.x + 10,
                y: bounds.y - 15,
                width: bounds.width - 20,
                height: 30
            };
            
            return bounds;
        }

        // Calculate minimum width needed for a group based on its name and content
        function calculateMinimumGroupWidth(group) {
            // Set up canvas context for text measurement
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = '14px Sora, sans-serif';
            
            // Measure group name width
            const nameWidth = tempCtx.measureText(group.name).width;
            
            // Measure token count text width
            const countText = `(${group.nodes.length})`;
            const countWidth = tempCtx.measureText(countText).width;
            
            // Calculate minimum width needed
            // 35px (arrow) + nameWidth + 20px (spacing) + countWidth + 10px (padding) + 60px (buttons)
            const minWidth = 35 + nameWidth + 20 + countWidth + 10 + 60;
            
            // Ensure minimum width is at least 200px for collapsed groups
            return Math.max(minWidth, 200);
        }
        
        // Ungroup nodes
        function ungroupNodes(groupId) {
            const group = groups.find(g => g.id === groupId);
            if (!group) return;
            
            // Remove group reference from nodes
            group.nodes.forEach(node => {
                delete node.groupId;
            });
            
            // Remove group
            const groupIndex = groups.findIndex(g => g.id === groupId);
            groups.splice(groupIndex, 1);
            

            render();
        }
        
        // Add node to existing group
        function addNodeToGroup(node, groupId) {
            const group = groups.find(g => g.id === groupId);
            if (!group) return;
            
            node.groupId = groupId;
            group.nodes.push(node);
            updateGroupBounds(groupId);
            

            render();
        }
        
        // Update group bounds when nodes change
        function updateGroupBounds(groupId) {
            const group = groups.find(g => g.id === groupId);
            if (!group) return;
            
            // Store current bounds before updating
            const oldBounds = { ...group.bounds };
            
            // Calculate new bounds based on current node positions
            const newBounds = calculateGroupBounds(group.nodes);
            
            // If group was collapsed, maintain collapsed state but update position
            if (group.isCollapsed) {
                // Update original bounds to reflect new node positions
                group.originalBounds = { ...newBounds };
                
                // Force collapsed dimensions to be small and center on new node positions
                const centerX = newBounds.x + newBounds.width / 2;
                const centerY = newBounds.y + newBounds.height / 2;
                const collapsedWidth = calculateMinimumGroupWidth(group); // Dynamic width based on content
                const collapsedHeight = 80;  // Fixed height
                
                group.bounds = {
                    x: centerX - collapsedWidth / 2,
                    y: centerY - collapsedHeight / 2,
                    width: collapsedWidth,
                    height: collapsedHeight
                };
                
                // Update header bounds for collapsed state
                group.bounds.headerBounds = {
                    x: group.bounds.x + 10,
                    y: group.bounds.y - 15,
                    width: group.bounds.width - 20,
                    height: 30
                };
            } else {
                // Group is expanded, use full bounds
                group.bounds = newBounds;
            }
            

            
            render();
        }
        
        // Remove node from group
        function removeNodeFromGroup(node, groupId) {
            const group = groups.find(g => g.id === groupId);
            if (!group) return;
            
            delete node.groupId;
            const nodeIndex = group.nodes.findIndex(n => n.id === node.id);
            if (nodeIndex >= 1) {
                group.nodes.splice(nodeIndex, 1);
            }
            
            // If group has less than 2 nodes, remove it
            if (group.nodes.length < 2) {
                const groupIndex = groups.findIndex(g => g.id === groupId);
                groups.splice(groupIndex, 1);

            } else {
                updateGroupBounds(groupId);

            }
            
            render();
        }
        
        // Toggle group collapse/expand
        function toggleGroupCollapse(groupId) {
            const group = groups.find(g => g.id === groupId);
            if (!group) return;
            
            if (group.isCollapsed) {
                // Expand group
                group.isCollapsed = false;
                group.bounds = group.originalBounds || calculateGroupBounds(group.nodes);
                group.originalBounds = null;
    
            } else {
                // Collapse group with max-width constraint
                group.originalBounds = { ...group.bounds };
                const centerX = group.bounds.x + group.bounds.width / 2;
                const centerY = group.bounds.y + group.bounds.height / 2;
                
                // Force collapsed dimensions to be small
                const collapsedWidth = calculateMinimumGroupWidth(group); // Dynamic width based on content
                const collapsedHeight = 80;  // Fixed height
                
                group.bounds = {
                    x: centerX - collapsedWidth / 2,
                    y: centerY - collapsedHeight / 2,
                    width: collapsedWidth,
                    height: collapsedHeight
                };
                group.isCollapsed = true;

            }
            
            // Update header bounds for the new state
            if (group.bounds) {
                group.bounds.headerBounds = {
                    x: group.bounds.x + 10,
                    y: group.bounds.y - 15,
                    width: group.bounds.width - 20,
                    height: 30
                };
            }
            
            render();
        }
        
        // Rename group
        function renameGroup(groupId) {
            const group = groups.find(g => g.id === groupId);
            if (!group) return;
            
            // Show the rename modal
            const modal = document.getElementById('dtmc-rename-group-modal');
            const nameInput = document.getElementById('group-new-name');
            
            if (!modal || !nameInput) {
                console.error('Rename modal elements not found');
                return;
            }
            
            // Set current group name in input
            nameInput.value = group.name;
            
            // Store the group ID for the confirm button
            modal.dataset.groupId = groupId;
            
            // Show modal
            modal.style.display = 'flex';
            
            // Focus on input
            nameInput.focus();
            nameInput.select();
            

        }
        
        // ===== GROUP RENDERING FUNCTIONS =====
        
        // Draw all groups on the canvas
        function drawGroups() {
            groups.forEach(group => {
                if (group.bounds) {
                    // Check if this group is being dragged
                    const isBeingDragged = isDraggingGroup && draggedGroup && draggedGroup.id === group.id;
                    
                    // Draw group boundary with different styling when dragging
                    if (isBeingDragged) {
                        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-border-dragging').trim();
                        ctx.lineWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-line-width-dragging'));
                        const dashDragging = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-dash-dragging'));
                        ctx.setLineDash([dashDragging, dashDragging / 2]); // Different dash pattern when dragging
                    } else {
                        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-border-normal').trim();
                        ctx.lineWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-line-width-normal'));
                        const dashNormal = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-dash-normal'));
                        ctx.setLineDash([dashNormal, dashNormal]); // Normal dashed line
                    }
                    
                    ctx.beginPath();
                    ctx.roundRect(group.bounds.x, group.bounds.y, group.bounds.width, group.bounds.height, 10);
                    ctx.stroke();
                    
                    // Reset line dash
                    ctx.setLineDash([]);
                    
                    // Draw group header (dark grey bar overlapping the top)
                    const headerBounds = group.bounds.headerBounds;
                    if (headerBounds) {
                                            // Header background
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-header-bg').trim();
                    ctx.beginPath();
                    ctx.roundRect(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height, 8);
                    ctx.fill();
                    
                    // Header border
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-border-header').trim();
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height, 8);
                    ctx.stroke();
                    
                    // Arrow indicator (right-pointing for expanded, down for collapsed)
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-header-text').trim();
                    ctx.font = '16px Sora, sans-serif';
                    ctx.textAlign = 'center';
                    const arrow = group.isCollapsed ? '‚ñ∂' : '‚ñº';
                    ctx.fillText(arrow, headerBounds.x + 20, headerBounds.y + 20);
                    
                    // Group name
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-header-text').trim();
                    ctx.font = '14px Sora, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText(group.name, headerBounds.x + 35, headerBounds.y + 20);
                    
                    // Token count
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-header-text-secondary').trim();
                    ctx.font = '12px Sora, sans-serif';
                    const countText = `(${group.nodes.length})`;
                    const countWidth = ctx.measureText(countText).width;
                    ctx.fillText(countText, headerBounds.x + headerBounds.width - countWidth - 10, headerBounds.y + 20);
                        
                        // Visual indicator for draggable area (subtle background)
                        const draggableAreaX = headerBounds.x + 30;
                        const draggableAreaWidth = headerBounds.width - 90; // Between arrow (30px) and buttons (60px)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Very subtle white overlay
                        ctx.beginPath();
                        ctx.roundRect(draggableAreaX, headerBounds.y + 2, draggableAreaWidth, headerBounds.height - 4, 4);
                        ctx.fill();
                        
                        // Action buttons (rename and ungroup)
                        const buttonSize = 20;
                        const buttonSpacing = 5;
                        const buttonY = headerBounds.y + 5;
                        
                        // Rename button
                        const renameX = headerBounds.x + headerBounds.width - 60;
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-button-bg').trim();
                        ctx.beginPath();
                        ctx.roundRect(renameX, buttonY, buttonSize, buttonSize, 4);
                        ctx.fill();
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-button-text').trim();
                        ctx.font = '12px Sora, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚úè', renameX + buttonSize/2, buttonY + buttonSize/2 + 4);
                        
                        // Ungroup button
                        const ungroupX = renameX - buttonSize - buttonSpacing;
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-button-bg').trim();
                        ctx.beginPath();
                        ctx.roundRect(ungroupX, buttonY, buttonSize, buttonSize, 4);
                        ctx.fill();
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dtmc-group-button-text').trim();
                        ctx.font = '12px Sora, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚äò', ungroupX + buttonSize/2, buttonY + buttonSize/2 + 4);
                        
                        // Store button bounds for click detection
                        group.renameButtonBounds = {
                            x: renameX,
                            y: buttonY,
                            width: buttonSize,
                            height: buttonSize
                        };
                        group.ungroupButtonBounds = {
                            x: ungroupX,
                            y: buttonY,
                            width: buttonSize,
                            height: buttonSize
                        };
                    }
                    
                    // If group is collapsed, draw token information on the collapsed group body
                    if (group.isCollapsed) {
                        // Draw collapsed group content
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)'; // Light blue background
                        ctx.beginPath();
                        ctx.roundRect(group.bounds.x + 5, group.bounds.y + 5, group.bounds.width - 10, group.bounds.height - 10, 8);
                        ctx.fill();
                        
                        // Draw group name in the center
                        ctx.fillStyle = '#3b82f6';
                        ctx.font = '14px Sora, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(group.name, group.bounds.x + group.bounds.width / 2, group.bounds.y + group.bounds.height / 2 - 5);
                        
                        // Draw token count and connection info
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '12px Sora, sans-serif';
                        ctx.textAlign = 'center';
                        
                        // Count connected tokens
                        const connectedTokens = group.nodes.filter(node => {
                            return connections.some(conn => 
                                (conn.startNode.id === node.id || conn.endNode.id === node.id) &&
                                (conn.startNode.groupId === group.id || conn.endNode.groupId === group.id)
                            );
                        }).length;
                        
                        const infoText = `${group.nodes.length} tokens${connectedTokens > 0 ? ` (${connectedTokens} connected)` : ''}`;
                        ctx.fillText(infoText, group.bounds.x + group.bounds.width / 2, group.bounds.y + group.bounds.height / 2 + 10);
                    }
                    
                    // Store group bounds for click detection
                    group.clickBounds = {
                        x: group.bounds.x,
                        y: group.bounds.y,
                        width: group.bounds.width,
                        height: group.bounds.height
                    };
                }
            });
        }
        
        // Update group menu visibility based on selection
        function updateGroupMenu() {
            const groupMenu = document.getElementById('dtmc-group-menu');
            if (!groupMenu) return;
            
            if (selectedNodes.length >= 2) {
                // Position group menu above the selection
                const centerX = selectedNodes.reduce((sum, node) => sum + node.x + getBubbleWidth() / 2, 0) / selectedNodes.length;
                const minY = Math.min(...selectedNodes.map(node => node.y));
                
                const menuX = centerX * zoomLevel + panOffset.x;
                const menuY = (minY - 10) * zoomLevel + panOffset.y - 80;
                
                groupMenu.style.left = menuX + 'px';
                groupMenu.style.top = menuY + 'px';
                groupMenu.style.display = 'flex';
            } else {
                groupMenu.style.display = 'none';
            }
        }
        
        // Show group management menu
        function showGroupManagementMenu(x, y, group) {
            const menu = document.getElementById('dtmc-group-management-menu');
            if (!menu) return;
            
            menu.style.left = (x - 90) + 'px'; // Center the menu
            menu.style.top = (y - 40) + 'px';
            menu.style.display = 'flex';
            menu.dataset.groupId = group.id;
        }
        
        // Hide group management menu
        function hideGroupManagementMenu() {
            const menu = document.getElementById('dtmc-group-management-menu');
            if (menu) {
                menu.style.display = 'none';
                menu.dataset.groupId = '';
            }
        }
        
        // ===== FLOATING MENU FUNCTIONS =====
        
        // Show floating menu at specified position
        function showFloatingMenu(x, y, node) {

            
            const menu = document.getElementById('dtmc-floating-menu');

            
            if (!menu) {
                console.error('‚ùå Menu element not found!');
                return;
            }
            
            // Position menu above the bubble, horizontally centered
            const menuWidth = 180;
            const bubbleCenterX = node.x + getBubbleWidth() / 2;
            const menuX = bubbleCenterX * zoomLevel + panOffset.x - menuWidth / 2 + (getBubbleWidth() * 0.5);
            const menuY = (node.y - 10) * zoomLevel + panOffset.y - 80; // 10px above bubble, accounting for menu height
            

            
            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            menu.style.display = 'flex';
            
            // Store reference to the node for delete operations
            menu.dataset.nodeId = nodes.indexOf(node);
            
            // Show/hide remove from group button based on node's group status
            const removeFromGroupBtn = document.getElementById('dtmc-remove-from-group-btn');
            if (removeFromGroupBtn) {
                removeFromGroupBtn.style.display = node.groupId ? 'flex' : 'none';
            }
            

        }
        
        // Hide floating menu
        function hideFloatingMenu() {
            const menu = document.getElementById('dtmc-floating-menu');
            if (menu) {
                menu.style.display = 'none';
                menu.dataset.nodeId = '';
            }
        }
        
        // Delete node from canvas
        function deleteNodeFromCanvas() {
            const menu = document.getElementById('dtmc-floating-menu');
            const nodeIndex = parseInt(menu.dataset.nodeId);
            
            if (nodeIndex >= 0 && nodeIndex < nodes.length) {
                const node = nodes[nodeIndex];

                
                // Remove all connections involving this node
                connections = connections.filter(conn => 
                    conn.startNode !== node && conn.endNode !== node
                );
                
                // Remove the node
                nodes.splice(nodeIndex, 1);
                
                // Save state and re-render
                saveState();
                render();
                hideFloatingMenu();
                

            }
        }
        
        // Delete token entirely (from both canvas and sidebar)
        function deleteTokenEntirely() {
            const menu = document.getElementById('dtmc-floating-menu');
            const nodeIndex = parseInt(menu.dataset.nodeId);
            
            if (nodeIndex >= 0 && nodeIndex < nodes.length) {
                const node = nodes[nodeIndex];

                
                // Remove all connections involving this node
                connections = connections.filter(conn => 
                    conn.startNode !== node && conn.endNode !== node
                );
                
                // Remove the node from canvas
                nodes.splice(nodeIndex, 1);
                
                // Remove the token from the sidebar
                const layer = node.layer;
                if (tokens[layer]) {
                    tokens[layer] = tokens[layer].filter(t => t.name !== node.name);

                }
                
                // Save state and re-render
                saveState();
                render();
                renderSidebar();
                hideFloatingMenu();
                

            }
        }

        // Canvas drop handling
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        // Parse token reference (e.g., "{primitive.primary-blue}" -> {layer: "primitive", name: "primary-blue"})
        function parseTokenReference(value) {
            if (!value || typeof value !== 'string') return null;
            
            const match = value.match(/^\{([^.]+)\.([^}]+)\}$/);
            if (match) {
                return {
                    layer: match[1],
                    name: match[2]
                };
            }
            return null;
        }

        // Determine the best socket pair based on node positions
        function getBestSocketPair(startNode, endNode) {
            const startCenterX = startNode.x + getBubbleWidth() / 2;
            const startCenterY = startNode.y + getBubbleHeight() / 2;
            const endCenterX = endNode.x + getBubbleWidth() / 2;
            const endCenterY = endNode.y + getBubbleHeight() / 2;
            
            const deltaX = endCenterX - startCenterX;
            const deltaY = endCenterY - startCenterY;
            
            // Determine if nodes are positioned horizontally or vertically
            const isHorizontal = Math.abs(deltaX) > Math.abs(deltaY);
            
            let startSocket, endSocket;
            
            if (isHorizontal) {
                // Nodes are positioned side by side
                if (deltaX > 0) {
                    // End node is to the right of start node
                    startSocket = 'right';
                    endSocket = 'left';
                } else {
                    // End node is to the left of start node
                    startSocket = 'left';
                    endSocket = 'right';
                }
            } else {
                // Nodes are positioned vertically
                if (deltaY > 0) {
                    // End node is below start node
                    startSocket = 'bottom';
                    endSocket = 'top';
                } else {
                    // End node is above start node
                    startSocket = 'top';
                    endSocket = 'bottom';
                }
            }
            
            return { startSocket, endSocket };
        }

        // Create automatic connections for token references
        function createAutomaticConnections(newNode) {
            // 1. Check if the new node references any existing nodes on the canvas
            const reference = parseTokenReference(newNode.value);
            if (reference) {
                const referencedNode = nodes.find(node => 
                    node.name === reference.name && 
                    node.layer === reference.layer &&
                    node.id !== newNode.id // Don't connect to itself
                );

                if (referencedNode) {
                    createConnectionBetweenNodes(referencedNode, newNode);
                } else {
                    console.log(`Referenced token ${reference.layer}.${reference.name} not found on canvas`);
                }
            }

            // 2. Check if any existing nodes on the canvas reference the new node
            nodes.forEach(existingNode => {
                if (existingNode.id === newNode.id) return; // Skip the new node itself
                
                const existingReference = parseTokenReference(existingNode.value);
                if (existingReference && 
                    existingReference.name === newNode.name && 
                    existingReference.layer === newNode.layer) {
                    createConnectionBetweenNodes(existingNode, newNode);
                }
            });
        }

        // Helper function to create a connection between two nodes
        function createConnectionBetweenNodes(startNode, endNode) {
            // Determine the best socket pair based on node positions
            const { startSocket, endSocket } = getBestSocketPair(startNode, endNode);
            
            // Create connection from start node to end node
            const connection = {
                id: Date.now(),
                startNode: startNode,
                endNode: endNode,
                startSocket: startSocket,
                endSocket: endSocket,
                fromNode: startNode.name,
                fromLayer: startNode.layer,
                toNode: endNode.name,
                toLayer: endNode.layer
            };

            // Check if connection already exists (in either direction)
            const existingConnection = connections.find(conn => 
                (conn.fromNode === connection.fromNode &&
                 conn.fromLayer === connection.fromLayer &&
                 conn.toNode === connection.toNode &&
                 conn.toLayer === connection.toLayer) ||
                (conn.fromNode === connection.toNode &&
                 conn.fromLayer === connection.toLayer &&
                 conn.toNode === connection.fromNode &&
                 conn.toLayer === connection.fromLayer)
            );

            if (!existingConnection) {
                connections.push(connection);
                console.log(`Auto-created connection: ${startNode.layer}.${startNode.name} -> ${endNode.layer}.${endNode.name} (${startSocket} -> ${endSocket})`);
            }
        }

        // Migrate existing connections to use socket positions
        function migrateConnectionsToSockets() {
            connections.forEach(connection => {
                // If connection doesn't have socket information, add it
                if (!connection.startSocket || !connection.endSocket) {
                    const { startSocket, endSocket } = getBestSocketPair(connection.startNode, connection.endNode);
                    connection.startSocket = startSocket;
                    connection.endSocket = endSocket;
                    console.log(`Migrated connection: ${connection.startNode.name} -> ${connection.endNode.name} (${startSocket} -> ${endSocket})`);
                }
            });
        }

        // Update socket positions for connections when nodes are moved
        function updateConnectionSockets() {
            connections.forEach(connection => {
                // Re-evaluate the best socket pair based on current node positions
                const { startSocket, endSocket } = getBestSocketPair(connection.startNode, connection.endNode);
                connection.startSocket = startSocket;
                connection.endSocket = endSocket;
            });
        }

        // Create automatic connections for all nodes that have references
        function createAllAutomaticConnections() {
            // First migrate any existing connections to use sockets
            migrateConnectionsToSockets();
            
            // Create new automatic connections for all nodes
            // The duplicate check in createConnectionBetweenNodes will prevent duplicates
            nodes.forEach(node => {
                createAutomaticConnections(node);
            });
        }

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Create new node from token
            const newNode = {
                id: Date.now(),
                x: x - getBubbleWidth() / 2,
                y: y - getBubbleHeight() / 2,
                name: draggedToken.name,
                value: draggedToken.value,
                type: draggedToken.type,
                layer: draggedToken.layer,
                originalValue: draggedToken.value // Store original value for restoration
            };
            
            nodes.push(newNode);
            
            // Create automatic connections if the token has references
            createAutomaticConnections(newNode);
            
            saveState();
            render();
            

        });

        // Rendering functions
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(zoomLevel, zoomLevel);
            
            // Draw groups first (behind everything)
            drawGroups();
            
            // Draw connections (consolidate when groups are collapsed)

            drawConnectionsWithGroupConsolidation();
            
            // Draw nodes on top (always draw them, but handle grouped nodes differently)
            nodes.forEach(node => {
                if (node.groupId) {
                    const group = groups.find(g => g.id === node.groupId);
                    if (group && group.isCollapsed) {
                        // Don't draw nodes in collapsed groups
                        return;
                    }
                }
                drawNode(node);
            });
            
            ctx.restore();
            
            // Draw lasso selection (on top of everything)
            if (isLassoSelecting) {
                drawLassoSelection();
            }
            
            // Update mini-map if visible
            const minimap = document.querySelector('.dtmc-minimap');
            if (minimap && !minimap.classList.contains('hidden')) {
                renderMiniMap();
            }
            
            // Show/hide group menu based on selection
            updateGroupMenu();
        }

        function drawNode(node) {
            // Check if node is selected (single or multi-selection)
            const isSelected = selectedNode && selectedNode.id === node.id;
            const isMultiSelected = selectedNodes.some(n => n.id === node.id);
            
            // Check if this is a grouped node being dragged
            const isGroupedNodeBeingDragged = isDraggingGroupedNode && draggedGroupedNode && draggedGroupedNode.id === node.id;
            
            // Get CSS variables for bubble styling
            const bubbleBgColor = getCSSVariable('--dtmc-bubble-bg-color');
            const bubbleBlur = parseCSSValue(getCSSVariable('--dtmc-bubble-blur'));
            const bubbleRadius = parseCSSValue(getCSSVariable('--dtmc-bubble-radius'));
            const bubbleShadowColor = getCSSVariable('--dtmc-bubble-shadow-color');
            const bubbleNameColor = getCSSVariable('--dtmc-bubble-name-color');
            const bubbleNameFontSize = getCSSVariable('--dtmc-bubble-name-font-size');
            const bubbleNameYOffset = parseCSSValue(getCSSVariable('--dtmc-bubble-name-y-offset'));
            
            // Draw node background with CSS-controlled styling
            ctx.fillStyle = bubbleBgColor;
            
            // Different border styling for grouped nodes being dragged
            if (isGroupedNodeBeingDragged) {
                ctx.strokeStyle = '#f59e0b'; // Orange border when dragging grouped node
                ctx.lineWidth = 3;
            } else {
                ctx.strokeStyle = isSelected || isMultiSelected ? '#3b82f6' : '#475569';
                ctx.lineWidth = isSelected || isMultiSelected ? 2 : 1;
            }
            
            // Apply backdrop blur effect (simulated with shadow)
            ctx.shadowColor = bubbleShadowColor;
            ctx.shadowBlur = bubbleBlur;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.beginPath();
            ctx.roundRect(node.x, node.y, getBubbleWidth(), getBubbleHeight(), bubbleRadius);
            ctx.fill();
            
            // Reset shadow for border
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw gradient border based on layer type
            drawGradientBorder(node);
            
            // Node content
            ctx.textAlign = 'center';
            
            // Token name with CSS-controlled styling and text wrapping
            ctx.fillStyle = bubbleNameColor;
            ctx.font = `${bubbleNameFontSize} Sora, system-ui, sans-serif`;
            ctx.textAlign = 'center';
            
            // Wrap text if it's too long
            const maxWidth = getBubbleWidth() - 20; // 10px padding on each side
            const wrappedLines = wrapText(ctx, node.name, maxWidth, 10);
            
            // Draw each line
            const lineHeight = 16; // Adjust based on font size
            const startY = node.y + bubbleNameYOffset - ((wrappedLines.length - 1) * lineHeight / 2);
            
            // Debug: Log text wrapping info
            if (wrappedLines.length > 1) {

            }
            
            wrappedLines.forEach((line, index) => {
                // Ensure text stays within bubble bounds
                const textX = node.x + getBubbleWidth() / 2;
                const textY = startY + (index * lineHeight);
                
                // Check if text would go outside bubble bounds
                const textWidth = ctx.measureText(line).width;
                if (textWidth > maxWidth) {
                    console.warn(`Text still too wide: "${line}" (${textWidth}px > ${maxWidth}px)`);
                }
                
                ctx.fillText(line, textX, textY);
            });
            
            // Token value in black background container
            drawValueContainer(node);
            
            // Draw sockets
            drawSockets(node);
        }
        
        // Draw lasso selection (rectangle)
        function drawLassoSelection() {
            if (!isLassoSelecting || lassoPath.length < 1) return;
            
            ctx.save();
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)'; // Light blue fill
            
            // Calculate rectangle dimensions
            const startX = lassoStartPoint.x;
            const startY = lassoStartPoint.y;
            const endX = lassoCurrentPoint.x;
            const endY = lassoCurrentPoint.y;
            
            const rectX = Math.min(startX, endX);
            const rectY = Math.min(startY, endY);
            const rectWidth = Math.abs(endX - startX);
            const rectHeight = Math.abs(endY - startY);
            
            // Draw filled rectangle
            ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
            
            // Draw rectangle outline
            ctx.beginPath();
            ctx.rect(rectX, rectY, rectWidth, rectHeight);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Check if a point is inside the lasso rectangle
        function isPointInLasso(x, y) {
            if (!isLassoSelecting || lassoPath.length < 1) return false;
            
            // Calculate rectangle bounds
            const startX = lassoStartPoint.x;
            const startY = lassoStartPoint.y;
            const endX = lassoCurrentPoint.x;
            const endY = lassoCurrentPoint.y;
            
            const rectX = Math.min(startX, endX);
            const rectY = Math.min(startY, endY);
            const rectWidth = Math.abs(endX - startX);
            const rectHeight = Math.abs(endY - startY);
            
            // Convert canvas coordinates to world coordinates
            const worldX = (x - panOffset.x) / zoomLevel;
            const worldY = (y - panOffset.y) / zoomLevel;
            
            // Check if point is inside rectangle
            return worldX >= rectX && worldX <= rectX + rectWidth && 
                   worldY >= rectY && worldY <= rectY + rectHeight;
        }
        
        // Select nodes within lasso rectangle
        function selectNodesInLasso() {
            const nodesInLasso = [];
            
            // Calculate rectangle bounds in world coordinates
            const startX = (lassoStartPoint.x - panOffset.x) / zoomLevel;
            const startY = (lassoStartPoint.y - panOffset.y) / zoomLevel;
            const endX = (lassoCurrentPoint.x - panOffset.x) / zoomLevel;
            const endY = (lassoCurrentPoint.y - panOffset.y) / zoomLevel;
            
            const rectX = Math.min(startX, endX);
            const rectY = Math.min(startY, endY);
            const rectWidth = Math.abs(endX - startX);
            const rectHeight = Math.abs(endY - startY);
            
            nodes.forEach(node => {
                // Check if node is within the rectangle bounds
                const nodeLeft = node.x;
                const nodeRight = node.x + getBubbleWidth();
                const nodeTop = node.y;
                const nodeBottom = node.y + getBubbleHeight();
                
                // Check for overlap between node and selection rectangle
                if (nodeLeft < rectX + rectWidth && 
                    nodeRight > rectX && 
                    nodeTop < rectY + rectHeight && 
                    nodeBottom > rectY) {
                    nodesInLasso.push(node);
                }
            });
            
            if (nodesInLasso.length > 0) {
                selectedNodes = nodesInLasso;
                selectedNode = nodesInLasso[0]; // Set primary selection

            }
        }
        
        function drawGradientBorder(node) {
            // Check if node is selected (single or multi-selection)
            const isSelected = selectedNode && selectedNode.id === node.id;
            const isMultiSelected = selectedNodes.some(n => n.id === node.id);
            
            // Get CSS variables for border styling
            const baseBorderWidth = parseCSSValue(getCSSVariable('--dtmc-bubble-border-width'));
            const borderWidth = isSelected || isMultiSelected ? 2 : baseBorderWidth; // Use 2px for selected, CSS value for unselected
            const borderRadius = parseCSSValue(getCSSVariable('--dtmc-bubble-border-radius'));
            const borderEndColor = getCSSVariable('--dtmc-bubble-border-end-color');
            
            let startColor, endColor;
            
            // Set gradient colors based on layer type using CSS variables
            switch (node.layer) {
                case 'primitive':
                    startColor = getCSSVariable('--dtmc-primitive-start');
                    endColor = getCSSVariable('--dtmc-primitive-end');
                    break;
                case 'base':
                    startColor = getCSSVariable('--dtmc-base-start');
                    endColor = getCSSVariable('--dtmc-base-end');
                    break;
                case 'semantic':
                    startColor = getCSSVariable('--dtmc-semantic-start');
                    endColor = getCSSVariable('--dtmc-semantic-end');
                    break;
                case 'specific':
                    startColor = getCSSVariable('--dtmc-specific-start');
                    endColor = getCSSVariable('--dtmc-specific-end');
                    break;
                default:
                    startColor = getCSSVariable('--dtmc-primitive-start');
                    endColor = getCSSVariable('--dtmc-primitive-end');
            }
            
            // Create gradient outline by drawing the border as a stroke
            ctx.lineWidth = borderWidth;
            
            // Use blue color for selected nodes, gradient for unselected
            if (isSelected || isMultiSelected) {
                ctx.strokeStyle = '#3b82f6'; // Blue for selected nodes
            } else {
                // Create gradient for the border
                const gradient = ctx.createLinearGradient(
                    node.x, node.y, 
                    node.x, node.y + getBubbleHeight() / 2
                );
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                ctx.strokeStyle = gradient;
            }
            ctx.beginPath();
            ctx.roundRect(node.x + borderWidth/2, node.y + borderWidth/2, getBubbleWidth() - borderWidth, getBubbleHeight() - borderWidth, borderRadius);
            ctx.stroke();
            
            // Draw the bottom half with solid color
            ctx.strokeStyle = isSelected || isMultiSelected ? '#3b82f6' : borderEndColor;
            ctx.beginPath();
            ctx.moveTo(node.x + borderWidth/2, node.y + getBubbleHeight() / 2);
            ctx.lineTo(node.x + getBubbleWidth() - borderWidth/2, node.y + getBubbleHeight() / 2);
            ctx.lineTo(node.x + getBubbleWidth() - borderWidth/2, node.y + getBubbleHeight() - borderWidth/2);
            ctx.lineTo(node.x + borderWidth/2, node.y + getBubbleHeight() - borderWidth/2);
            ctx.closePath();
            ctx.stroke();
        }
        
        function drawValueContainer(node) {
            // Get CSS variables for value container styling
            const containerBg = getCSSVariable('--dtmc-value-container-bg');
            const containerRadius = parseCSSValue(getCSSVariable('--dtmc-value-container-radius'));
            const containerMarginX = parseCSSValue(getCSSVariable('--dtmc-value-container-margin-x'));
            const containerYOffset = parseCSSValue(getCSSVariable('--dtmc-value-container-y-offset'));
            const containerHeight = parseCSSValue(getCSSVariable('--dtmc-value-container-height'));
            const containerPaddingX = parseCSSValue(getCSSVariable('--dtmc-value-container-padding-x'));
            const containerPaddingY = parseCSSValue(getCSSVariable('--dtmc-value-container-padding-y'));
            const containerBorderWidth = parseCSSValue(getCSSVariable('--dtmc-value-container-border-width'));
            const containerBorderColor = getCSSVariable('--dtmc-value-container-border-color');
            
            // Get CSS variables for value text styling
            const valueTextColor = getCSSVariable('--dtmc-value-text-color');
            const valueTextFontSize = getCSSVariable('--dtmc-value-text-font-size');
            const valueTextFontWeight = getCSSVariable('--dtmc-value-text-font-weight');
            const valueTextLineHeight = parseCSSValue(getCSSVariable('--dtmc-value-text-line-height'));
            const valueTextAlign = getCSSVariable('--dtmc-value-text-align');
            const valueTextTransform = getCSSVariable('--dtmc-value-text-transform');
            
            const containerX = node.x + containerMarginX;
            const containerY = node.y + containerYOffset;
            const containerWidth = getBubbleWidth() - (containerMarginX * 2);
            
            // Draw background container
            ctx.fillStyle = containerBg;
            ctx.beginPath();
            ctx.roundRect(containerX, containerY, containerWidth, containerHeight, containerRadius);
            ctx.fill();
            
            // Draw container border if specified
            if (containerBorderWidth > 0) {
                ctx.strokeStyle = containerBorderColor;
                ctx.lineWidth = containerBorderWidth;
                ctx.beginPath();
                ctx.roundRect(containerX, containerY, containerWidth, containerHeight, containerRadius);
                ctx.stroke();
            }
            
            // Check if this is a primitive color token with a direct hex value (not a reference)
            const isPrimitiveColor = node.layer === 'primitive' && node.type === 'color';
            const isDirectColorValue = isPrimitiveColor && !node.value.startsWith('{') && !node.value.startsWith('$');
            
            if (isDirectColorValue) {
                // Draw color preview square
                const colorSquareSize = 14;
                const colorSquareX = containerX + 8;
                const colorSquareY = containerY + (containerHeight - colorSquareSize) / 2;
                
                // Draw color square background
                ctx.fillStyle = node.value;
                ctx.beginPath();
                ctx.roundRect(colorSquareX, colorSquareY, colorSquareSize, colorSquareSize, 3);
                ctx.fill();
                
                // Draw color square border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(colorSquareX, colorSquareY, colorSquareSize, colorSquareSize, 3);
                ctx.stroke();
                
                // Adjust text position to make room for color square
                const textX = node.x + getBubbleWidth() / 2 + colorSquareSize / 2 + 4;
                ctx.fillStyle = valueTextColor;
                ctx.font = `${valueTextFontWeight} ${valueTextFontSize} Sora, system-ui, sans-serif`;
                ctx.textAlign = valueTextAlign;
                ctx.textBaseline = 'middle'; // This centers text vertically!
                
                // Wrap value text if needed
                const maxValueWidth = getBubbleWidth() - colorSquareSize - 20; // Account for color square and padding
                const textToDisplay = valueTextTransform === 'uppercase' ? node.value.toUpperCase() : 
                                    valueTextTransform === 'lowercase' ? node.value.toLowerCase() : node.value;
                const wrappedValueLines = wrapText(ctx, textToDisplay, maxValueWidth, 10);
                const valueLineHeight = parseFloat(valueTextFontSize) * valueTextLineHeight;
                
                // For single line, center perfectly
                if (wrappedValueLines.length === 1) {
                    const centerY = containerY + containerHeight / 2;
                    ctx.fillText(wrappedValueLines[0], textX, centerY);
                } else {
                    // For multiple lines, distribute evenly around center
                    const centerY = containerY + containerHeight / 2;
                    const startY = centerY - (wrappedValueLines.length - 1) * valueLineHeight / 2;
                    wrappedValueLines.forEach((line, index) => {
                        ctx.fillText(line, textX, startY + (index * valueLineHeight));
                    });
                }
            } else {
                // Draw value text normally (centered) with wrapping
                ctx.fillStyle = valueTextColor;
                ctx.font = `${valueTextFontWeight} ${valueTextFontSize} Sora, system-ui, sans-serif`;
                ctx.textAlign = valueTextAlign;
                ctx.textBaseline = 'middle'; // This centers text vertically!
                
                // Wrap value text if needed
                const maxValueWidth = getBubbleWidth() - 20; // 10px padding on each side
                const textToDisplay = valueTextTransform === 'uppercase' ? node.value.toUpperCase() : 
                                    valueTextTransform === 'lowercase' ? node.value.toLowerCase() : node.value;
                const wrappedValueLines = wrapText(ctx, textToDisplay, maxValueWidth, 10);
                const valueLineHeight = parseFloat(valueTextFontSize) * valueTextLineHeight;
                
                // For single line, center perfectly
                if (wrappedValueLines.length === 1) {
                    const centerY = containerY + containerHeight / 2;
                    ctx.fillText(wrappedValueLines[0], node.x + getBubbleWidth() / 2, centerY);
                } else {
                    // For multiple lines, distribute evenly around center
                    const centerY = containerY + containerHeight / 2;
                    const startY = centerY - (wrappedValueLines.length - 1) * valueLineHeight / 2;
                    wrappedValueLines.forEach((line, index) => {
                        ctx.fillText(line, node.x + getBubbleWidth() / 2, startY + (index * valueLineHeight));
                    });
                }
            }
        }
        
        function drawSockets(node) {
            // Check which sockets are connected
            const connectedSockets = new Set();
            connections.forEach(connection => {
                if (connection.startNode.id === node.id) {
                    connectedSockets.add(connection.startSocket);
                }
                if (connection.endNode.id === node.id) {
                    connectedSockets.add(connection.endSocket);
                }
            });
            
            // Top socket (INPUT - red)
            const topSocket = { x: node.x + getBubbleWidth() / 2, y: node.y };
            drawSocket(topSocket.x, topSocket.y, 'input', connectedSockets.has('top'), node);
            
            // Left socket (INPUT - red)
            const leftSocket = { x: node.x, y: node.y + getBubbleHeight() / 2 };
            drawSocket(leftSocket.x, leftSocket.y, 'input', connectedSockets.has('left'), node);
            
            // Right socket (OUTPUT - green)
            const rightSocket = { x: node.x + getBubbleWidth(), y: node.y + getBubbleHeight() / 2 };
            drawSocket(rightSocket.x, rightSocket.y, 'output', connectedSockets.has('right'), node);
            
            // Bottom socket (OUTPUT - green)
            const bottomSocket = { x: node.x + getBubbleWidth() / 2, y: node.y + getBubbleHeight() };
            drawSocket(bottomSocket.x, bottomSocket.y, 'output', connectedSockets.has('bottom'), node);
        }
        

        
        function drawSocket(x, y, type, isConnected, node) {
            // Get CSS variables for socket styling
            const socketRadius = parseCSSValue(getCSSVariable('--dtmc-socket-radius'));
            const socketConnectedColor = getCSSVariable('--dtmc-socket-connected-color');
            const socketDisconnectedColor = getCSSVariable('--dtmc-socket-disconnected-color');
            const socketStrokeColor = getCSSVariable('--dtmc-socket-stroke-color');
            const socketStrokeWidth = parseCSSValue(getCSSVariable('--dtmc-socket-stroke-width'));
            const socketInnerCircleRadius = parseCSSValue(getCSSVariable('--dtmc-socket-inner-circle-radius'));
            const socketPlusSize = parseCSSValue(getCSSVariable('--dtmc-socket-plus-size'));
            
            // Check if mouse is hovering over the entire node (bubble)
            const rect = canvas.getBoundingClientRect();
            const mouseX = (lastMousePos.x - rect.left - panOffset.x) / zoomLevel;
            const mouseY = (lastMousePos.y - rect.top - panOffset.y) / zoomLevel;
            
            const isHoveringOverNode = mouseX >= node.x && mouseX <= node.x + getBubbleWidth() &&
                                     mouseY >= node.y && mouseY <= node.y + getBubbleHeight();
            
            // Draw socket background
            if (isConnected) {
                ctx.fillStyle = socketConnectedColor;
            } else {
                ctx.fillStyle = socketDisconnectedColor;
            }
            
            ctx.beginPath();
            ctx.arc(x, y, socketRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw socket border with hover effect
            if (isHoveringOverNode) {
                // White border when hovering over the bubble
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = socketStrokeWidth * 1.5;
                ctx.stroke();
            } else {
                // No border when not hovering (transparent)
                // Don't draw border
            }
            
            // Draw socket content
            if (isConnected) {
                // When connected, just fill with connected color
                // (border already drawn above if hovering)
            } else {
                // When not connected, draw appropriate symbol
                if (type === 'input') {
                    // Draw small circle inside for input sockets
                    ctx.fillStyle = socketStrokeColor;
                    ctx.beginPath();
                    ctx.arc(x, y, socketInnerCircleRadius, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // Draw plus sign for output sockets
                    ctx.strokeStyle = socketStrokeColor;
                    ctx.lineWidth = socketStrokeWidth;
                    ctx.beginPath();
                    ctx.moveTo(x - socketPlusSize, y);
                    ctx.lineTo(x + socketPlusSize, y);
                    ctx.moveTo(x, y - socketPlusSize);
                    ctx.lineTo(x, y + socketPlusSize);
                    ctx.stroke();
                }
            }
        }
        
        function drawConnection(startNode, endNode, startSocket, endSocket) {
            const startPoint = getSocketPosition(startNode, startSocket);
            const endPoint = getSocketPosition(endNode, endSocket);
            
            // Get CSS variables for connection styling
            const connectionColor = getCSSVariable('--dtmc-connection-color');
            const connectionSelectedColor = getCSSVariable('--dtmc-connection-selected-color');
            const connectionWidth = parseCSSValue(getCSSVariable('--dtmc-connection-width'));
            const connectionSelectedWidth = parseCSSValue(getCSSVariable('--dtmc-connection-selected-width'));
            
            // Check if this connection is selected
            const isSelected = selectedConnection && 
                selectedConnection.startNode.id === startNode.id && 
                selectedConnection.endNode.id === endNode.id &&
                selectedConnection.startSocket === startSocket && 
                selectedConnection.endSocket === endSocket;
            
            // Draw connections with CSS-controlled styling
            if (isSelected) {
                ctx.strokeStyle = connectionSelectedColor;
                ctx.lineWidth = connectionSelectedWidth;
            } else {
                ctx.strokeStyle = connectionColor;
                ctx.lineWidth = connectionWidth;
            }
            
            // Create curved connection
            const controlPoint1 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: startPoint.y
            };
            
            const controlPoint2 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: endPoint.y
            };
            
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.bezierCurveTo(
                controlPoint1.x, controlPoint1.y,
                controlPoint2.x, controlPoint2.y,
                endPoint.x, endPoint.y
            );
            ctx.stroke();
            
            // Draw connection label only if this connection is being hovered
            if (hoveredConnection && 
                hoveredConnection.startNode.id === startNode.id && 
                hoveredConnection.endNode.id === endNode.id) {
                drawConnectionLabel(startPoint, endPoint, startNode, endNode);
            }
        }

        // Draw connections with group consolidation
        function drawConnectionsWithGroupConsolidation() {
            // Group connections by their source and target (considering collapsed groups)
            const connectionGroups = new Map();
            
            connections.forEach((connection, index) => {
                const startGroup = groups.find(g => g.id === connection.startNode.groupId);
                const endGroup = groups.find(g => g.id === connection.endNode.groupId);
                
                // Skip connections within the same collapsed group
                if (startGroup && endGroup && startGroup.id === endGroup.id && startGroup.isCollapsed) {
                    return;
                }
                
                // Skip if neither node is in a collapsed group - draw normally
                if ((!startGroup || !startGroup.isCollapsed) && (!endGroup || !endGroup.isCollapsed)) {
                    drawConnection(connection.startNode, connection.endNode, connection.startSocket, connection.endSocket);
                    return;
                }
                
                // Determine source and target identifiers
                let sourceId, targetId;
                
                if (startGroup && startGroup.isCollapsed) {
                    sourceId = `group_${startGroup.id}`;
                } else {
                    sourceId = `node_${connection.startNode.id}`;
                }
                
                if (endGroup && endGroup.isCollapsed) {
                    targetId = `group_${endGroup.id}`;
                } else {
                    targetId = `node_${connection.endNode.id}`;
                }
                
                const connectionKey = `${sourceId}_${targetId}`;
                
                if (!connectionGroups.has(connectionKey)) {
                    connectionGroups.set(connectionKey, {
                        connections: [],
                        sourceGroup: startGroup,
                        targetGroup: endGroup,
                        sourceNode: connection.startNode,
                        targetNode: connection.endNode,
                        startSocket: connection.startSocket,
                        endSocket: connection.endSocket
                    });
                }
                
                connectionGroups.get(connectionKey).connections.push(connection);
            });
            
            // Draw consolidated connections
            connectionGroups.forEach((group, key) => {
                drawConsolidatedConnection(group);
            });
        }
        
        // Get the best connection point on a group border based on direction
        function getGroupBorderConnectionPoint(group, targetPoint) {
            const bounds = group.bounds;
            const groupCenterX = bounds.x + bounds.width / 2;
            const groupCenterY = bounds.y + bounds.height / 2;
            
            // Calculate direction from group center to target
            const deltaX = targetPoint.x - groupCenterX;
            const deltaY = targetPoint.y - groupCenterY;
            
            // Determine which border to connect to based on direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal connection
                if (deltaX > 0) {
                    // Target is to the right, connect to right border
                    return {
                        x: bounds.x + bounds.width,
                        y: groupCenterY
                    };
                } else {
                    // Target is to the left, connect to left border
                    return {
                        x: bounds.x,
                        y: groupCenterY
                    };
                }
            } else {
                // Vertical connection
                if (deltaY > 0) {
                    // Target is below, connect to bottom border
                    return {
                        x: groupCenterX,
                        y: bounds.y + bounds.height
                    };
                } else {
                    // Target is above, connect to top border
                    return {
                        x: groupCenterX,
                        y: bounds.y
                    };
                }
            }
        }

        // Draw a consolidated connection representing multiple connections
        function drawConsolidatedConnection(connectionGroup) {
            const { sourceGroup, targetGroup, sourceNode, targetNode, startSocket, endSocket, connections } = connectionGroup;
            
            // Determine start and end points
            let startPoint, endPoint;
            
            if (sourceGroup && sourceGroup.isCollapsed) {
                // Calculate target point for direction calculation
                let targetPoint;
                if (targetGroup && targetGroup.isCollapsed) {
                    targetPoint = {
                        x: targetGroup.bounds.x + targetGroup.bounds.width / 2,
                        y: targetGroup.bounds.y + targetGroup.bounds.height / 2
                    };
                } else {
                    targetPoint = getSocketPosition(targetNode, endSocket);
                }
                
                // Get connection point on group border
                startPoint = getGroupBorderConnectionPoint(sourceGroup, targetPoint);
            } else {
                startPoint = getSocketPosition(sourceNode, startSocket);
            }
            
            if (targetGroup && targetGroup.isCollapsed) {
                // Calculate source point for direction calculation
                let sourcePoint;
                if (sourceGroup && sourceGroup.isCollapsed) {
                    sourcePoint = {
                        x: sourceGroup.bounds.x + sourceGroup.bounds.width / 2,
                        y: sourceGroup.bounds.y + sourceGroup.bounds.height / 2
                    };
                } else {
                    sourcePoint = getSocketPosition(sourceNode, startSocket);
                }
                
                // Get connection point on group border
                endPoint = getGroupBorderConnectionPoint(targetGroup, sourcePoint);
            } else {
                endPoint = getSocketPosition(targetNode, endSocket);
            }
            
            // Get CSS variables for connection styling
            const connectionColor = getCSSVariable('--dtmc-connection-color');
            const connectionWidth = parseCSSValue(getCSSVariable('--dtmc-connection-width'));
            
            // Draw consolidated connection with thicker line
            ctx.strokeStyle = connectionColor;
            ctx.lineWidth = connectionWidth * 1.5; // Make it slightly thicker
            
            // Create curved connection
            const controlPoint1 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: startPoint.y
            };
            
            const controlPoint2 = {
                x: startPoint.x + (endPoint.x - startPoint.x) * 0.5,
                y: endPoint.y
            };
            
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.bezierCurveTo(
                controlPoint1.x, controlPoint1.y,
                controlPoint2.x, controlPoint2.y,
                endPoint.x, endPoint.y
            );
            ctx.stroke();
            
            // Draw connection points on group borders
            if (sourceGroup && sourceGroup.isCollapsed) {
                drawGroupConnectionPoint(startPoint, 'output');
            }
            if (targetGroup && targetGroup.isCollapsed) {
                drawGroupConnectionPoint(endPoint, 'input');
            }
            
            // Draw connection count label
            drawConsolidatedConnectionLabel(startPoint, endPoint, connections.length);
        }
        
        // Draw a connection point on a group border
        function drawGroupConnectionPoint(point, type) {
            // Get CSS variables for socket styling
            const socketRadius = parseCSSValue(getCSSVariable('--dtmc-socket-radius'));
            const socketConnectedColor = getCSSVariable('--dtmc-socket-connected-color');
            const socketStrokeColor = getCSSVariable('--dtmc-socket-stroke-color');
            const socketStrokeWidth = parseCSSValue(getCSSVariable('--dtmc-socket-stroke-width'));
            const socketInnerCircleRadius = parseCSSValue(getCSSVariable('--dtmc-socket-inner-circle-radius'));
            const socketPlusSize = parseCSSValue(getCSSVariable('--dtmc-socket-plus-size'));
            
            // Draw socket background
            ctx.fillStyle = socketConnectedColor;
            ctx.beginPath();
            ctx.arc(point.x, point.y, socketRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw socket border
            ctx.strokeStyle = socketStrokeColor;
            ctx.lineWidth = socketStrokeWidth;
            ctx.stroke();
            
            // Draw socket content
            if (type === 'input') {
                // Draw small circle inside for input sockets
                ctx.fillStyle = socketStrokeColor;
                ctx.beginPath();
                ctx.arc(point.x, point.y, socketInnerCircleRadius, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                // Draw plus sign for output sockets
                ctx.strokeStyle = socketStrokeColor;
                ctx.lineWidth = socketStrokeWidth;
                ctx.beginPath();
                ctx.moveTo(point.x - socketPlusSize, point.y);
                ctx.lineTo(point.x + socketPlusSize, point.y);
                ctx.moveTo(point.x, point.y - socketPlusSize);
                ctx.lineTo(point.x, point.y + socketPlusSize);
                ctx.stroke();
            }
        }

        // Draw label for consolidated connection showing count
        function drawConsolidatedConnectionLabel(startPoint, endPoint, connectionCount) {
            // Save the current canvas context state
            ctx.save();
            
            // Calculate label position (middle of the connection)
            const labelX = (startPoint.x + endPoint.x) / 2;
            const labelY = (startPoint.y + endPoint.y) / 2;
            
            // Create label text
            const labelText = `${connectionCount} connections`;
            
            // Set text style
            ctx.font = '10px Inter, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw label background
            const textMetrics = ctx.measureText(labelText);
            const padding = 4;
            const bgWidth = textMetrics.width + padding * 2;
            const bgHeight = 14;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(
                labelX - bgWidth / 2,
                labelY - bgHeight / 2,
                bgWidth,
                bgHeight
            );
            
            // Draw label text
            ctx.fillStyle = '#ffffff';
            ctx.fillText(labelText, labelX, labelY);
            
            // Restore the canvas context state
            ctx.restore();
        }

        // Utility functions
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            render();
        }

        function saveState() {
            // Clear redo stack when new action is performed
            redoStack = [];
            
            undoStack.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections)),
                groups: JSON.parse(JSON.stringify(groups)),
                tokens: JSON.parse(JSON.stringify(tokens)),
                tokenGroups: JSON.parse(JSON.stringify(tokenGroups))
            });
            
            // Limit to 30 steps
            if (undoStack.length > 30) {
                undoStack.shift();
            }
        }

        function undo() {
            if (undoStack.length > 0) {
                // Save current state to redo stack
                redoStack.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    connections: JSON.parse(JSON.stringify(connections)),
                    groups: JSON.parse(JSON.stringify(groups)),
                    tokens: JSON.parse(JSON.stringify(tokens)),
                    tokenGroups: JSON.parse(JSON.stringify(tokenGroups))
                });
                
                // Limit redo stack to 30 steps
                if (redoStack.length > 30) {
                    redoStack.shift();
                }
                
                // Restore previous state
                const previousState = undoStack.pop();
                nodes = previousState.nodes;
                connections = previousState.connections;
                groups = previousState.groups || [];
                tokens = previousState.tokens || tokens;
                tokenGroups = previousState.tokenGroups || tokenGroups;
                
                render();
                renderSidebar();
            }
        }
        
        function redo() {
            if (redoStack.length > 0) {
                // Save current state to undo stack
                undoStack.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    connections: JSON.parse(JSON.stringify(connections)),
                    groups: JSON.parse(JSON.stringify(groups)),
                    tokens: JSON.parse(JSON.stringify(tokens)),
                    tokenGroups: JSON.parse(JSON.stringify(tokenGroups))
                });
                
                // Limit undo stack to 30 steps
                if (undoStack.length > 30) {
                    undoStack.shift();
                }
                
                // Restore next state
                const nextState = redoStack.pop();
                nodes = nextState.nodes;
                connections = nextState.connections;
                groups = nextState.groups || [];
                tokens = nextState.tokens || tokens;
                tokenGroups = nextState.tokenGroups || tokenGroups;
                
                render();
                renderSidebar();
            }
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all nodes and connections?')) {
                nodes = [];
                connections = [];
                groups = [];
                tokenGroups = {
                    primitive: {},
                    base: {},
                    semantic: {},
                    specific: {}
                };
                selectedSidebarTokens = [];
                undoStack = [];
                redoStack = [];
                render();
                renderSidebar();
            }
        }

        function exportJSON() {
            const data = {
                tokens: tokens,
                tokenGroups: tokenGroups,
                nodes: nodes,
                connections: connections,
                groups: groups,
                panOffset: panOffset,
                zoomLevel: zoomLevel,
                selectedLayer: selectedLayer,
                selectedTokenType: selectedTokenType,
                selectedNodes: selectedNodes.map(node => node.id), // Export selected node IDs
                metadata: {
                    version: '4.5',
                    exportDate: new Date().toISOString(),
                    totalTokens: Object.values(tokens).flat().length,
                    totalTokenGroups: Object.values(tokenGroups).flatMap(layer => Object.keys(layer)).length,
                    totalNodes: nodes.length,
                    totalConnections: connections.length,
                    totalGroups: groups.length
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dtmc-enhanced-tokens.json';
            a.click();
            URL.revokeObjectURL(url);
            

        }

        // Update nodes when tokens change
        function updateNodesWithToken(token, layer = null) {
            const targetLayer = layer || selectedLayer;
            const updatedNodes = [];
            
            nodes.forEach(node => {
                if (node.name === token.name && node.layer === targetLayer) {
                    node.value = token.value;
                    updatedNodes.push(node);
                }
            });
            
            // Re-evaluate connections for updated nodes
            updatedNodes.forEach(node => {
                createAutomaticConnections(node);
            });
            
            render();
        }

        // Update cursor based on what's under the mouse
        function updateCursor(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            // Check if hovering over a connection
            const connectionUnderMouse = getConnectionAtPoint(x, y);
            if (connectionUnderMouse) {
                canvas.style.cursor = 'pointer';
                // Only update and re-render if the hovered connection changed
                if (!hoveredConnection || 
                    hoveredConnection.startNode.id !== connectionUnderMouse.startNode.id || 
                    hoveredConnection.endNode.id !== connectionUnderMouse.endNode.id) {
                    hoveredConnection = connectionUnderMouse;
                    // Debounce the render to prevent rapid re-renders
                    if (hoverRenderTimeout) {
                        clearTimeout(hoverRenderTimeout);
                    }
                    hoverRenderTimeout = setTimeout(() => {
                        render(); // Re-render to show the label
                    }, 16); // ~60fps
                }
                return;
            } else {
                // Clear hovered connection if not hovering over any connection
                if (hoveredConnection) {
                    hoveredConnection = null;
                    // Debounce the render to prevent rapid re-renders
                    if (hoverRenderTimeout) {
                        clearTimeout(hoverRenderTimeout);
                    }
                    hoverRenderTimeout = setTimeout(() => {
                        render(); // Re-render to hide the label
                    }, 16); // ~60fps
                }
            }
            
            // Check if hovering over a group header's draggable area
            for (const group of groups) {
                if (isPointInGroupHeaderDraggableArea(x, y, group)) {
                    canvas.style.cursor = 'grab';
                    return;
                }
            }
            
            // Check if hovering over the group arrow
            for (const group of groups) {
                if (isPointOnGroupArrow(x, y, group)) {
                    canvas.style.cursor = 'pointer';
                    return;
                }
            }
            
            // Check if hovering over group buttons
            const groupButton = getGroupButtonAtPoint(x, y);
            if (groupButton) {
                canvas.style.cursor = 'pointer';
                return;
            }
            
            // Default cursor
            canvas.style.cursor = 'grab';
        }

        // Zoom control functions
        function zoomIn() {
            const newZoom = Math.min(MAX_ZOOM, zoomLevel * 1.2);
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                updateZoomDisplay();
                render();
            }
        }

        function zoomOut() {
            const newZoom = Math.max(MIN_ZOOM, zoomLevel / 1.2);
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                updateZoomDisplay();
                render();
            }
        }

        function resetZoom() {
            zoomLevel = 1.0;
            panOffset = { x: 0, y: 0 };
            updateZoomDisplay();
            render();
        }

        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('dtmc-zoom-level');
            zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
        }

        // Helper function to wrap text within a given width
        function wrapText(ctx, text, maxWidth, padding = 10) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0] || '';

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + " " + word;
                const width = ctx.measureText(testLine).width;
                if (width < maxWidth - (padding * 2)) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // Handle very long words that exceed the width
            const finalLines = [];
            for (const line of lines) {
                if (ctx.measureText(line).width > maxWidth - (padding * 2)) {
                    // Break long words
                    let remainingText = line;
                    while (remainingText.length > 0) {
                        let breakPoint = remainingText.length;
                        while (breakPoint > 0 && ctx.measureText(remainingText.substring(0, breakPoint)).width > maxWidth - (padding * 2)) {
                            breakPoint--;
                        }
                        if (breakPoint === 0) breakPoint = 1; // Prevent infinite loop
                        finalLines.push(remainingText.substring(0, breakPoint));
                        remainingText = remainingText.substring(breakPoint);
                    }
                } else {
                    finalLines.push(line);
                }
            }
            
            return finalLines;
        }

        // Draw connection labels
        function drawConnectionLabel(startPoint, endPoint, startNode, endNode) {
            // Save the current canvas context state
            ctx.save();
            
            // Calculate label position (middle of the connection)
            const labelX = (startPoint.x + endPoint.x) / 2;
            const labelY = (startPoint.y + endPoint.y) / 2;
            
            // Create label text
            const labelText = `${startNode.name} ‚Üí ${endNode.name}`;
            
            // Set text style
            ctx.font = '12px Inter, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw label background
            const textMetrics = ctx.measureText(labelText);
            const padding = 4;
            const bgWidth = textMetrics.width + padding * 2;
            const bgHeight = 16;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);
            
            // Draw label text
            ctx.fillStyle = '#ffffff';
            ctx.fillText(labelText, labelX, labelY);
            
            // Restore the canvas context state
            ctx.restore();
        }

        // Mini-map functionality
        function toggleMiniMap() {
            const minimap = document.querySelector('.dtmc-minimap');
            const showBtn = document.getElementById('dtmc-minimap-show-btn');
            
            minimap.classList.toggle('hidden');
            
            if (minimap.classList.contains('hidden')) {
                // Show the "Show Map" button when mini-map is hidden
                showBtn.style.display = 'flex';
            } else {
                // Hide the "Show Map" button when mini-map is visible
                showBtn.style.display = 'none';
                renderMiniMap();
            }
        }

        function renderMiniMap() {
            const minimapCanvas = document.getElementById('dtmc-minimap-canvas');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            if (nodes.length === 0) return;
            
            // Calculate bounds of all nodes
            let minX = Math.min(...nodes.map(n => n.x));
            let maxX = Math.max(...nodes.map(n => n.x + getBubbleWidth()));
            let minY = Math.min(...nodes.map(n => n.y));
            let maxY = Math.max(...nodes.map(n => n.y + getBubbleHeight()));
            
            // Add padding
            const padding = 50;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            // Calculate scale to fit in minimap
            const scaleX = minimapCanvas.width / (maxX - minX);
            const scaleY = minimapCanvas.height / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);
            
            // Draw nodes on minimap
            minimapCtx.fillStyle = '#3b82f6';
            nodes.forEach(node => {
                const minimapX = (node.x - minX) * scale;
                const minimapY = (node.y - minY) * scale;
                const minimapWidth = getBubbleWidth() * scale;
                const minimapHeight = getBubbleHeight() * scale;
                
                minimapCtx.fillRect(minimapX, minimapY, minimapWidth, minimapHeight);
            });
            
            // Draw connections on minimap
            minimapCtx.strokeStyle = '#60a5fa';
            minimapCtx.lineWidth = 1;
            connections.forEach(connection => {
                const startPoint = getSocketPosition(connection.startNode, connection.startSocket);
                const endPoint = getSocketPosition(connection.endNode, connection.endSocket);
                
                const startX = (startPoint.x - minX) * scale;
                const startY = (startPoint.y - minY) * scale;
                const endX = (endPoint.x - minX) * scale;
                const endY = (endPoint.y - minY) * scale;
                
                minimapCtx.beginPath();
                minimapCtx.moveTo(startX, startY);
                minimapCtx.lineTo(endX, endY);
                minimapCtx.stroke();
            });
            
            // Draw viewport indicator
            const viewportX = (-panOffset.x - minX) * scale;
            const viewportY = (-panOffset.y - minY) * scale;
            const viewportWidth = (canvas.width / zoomLevel - minX) * scale;
            const viewportHeight = (canvas.height / zoomLevel - minY) * scale;
            
            minimapCtx.strokeStyle = '#fbbf24';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
        }

        // Handle mini-map clicks for navigation
        function handleMiniMapClick(e) {
            const minimapCanvas = document.getElementById('dtmc-minimap-canvas');
            const rect = minimapCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            if (nodes.length === 0) return;
            
            // Calculate bounds (same logic as renderMiniMap)
            let minX = Math.min(...nodes.map(n => n.x));
            let maxX = Math.max(...nodes.map(n => n.x + getBubbleWidth()));
            let minY = Math.min(...nodes.map(n => n.y));
            let maxY = Math.max(...nodes.map(n => n.y + getBubbleHeight()));
            
            const padding = 50;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            const scaleX = minimapCanvas.width / (maxX - minX);
            const scaleY = minimapCanvas.height / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);
            
            // Convert click position to world coordinates
            const worldX = minX + (clickX / scale);
            const worldY = minY + (clickY / scale);
            
            // Center viewport on clicked position
            panOffset.x = -worldX + canvas.width / (2 * zoomLevel);
            panOffset.y = -worldY + canvas.height / (2 * zoomLevel);
            
            // Re-render
            render();
        }

        // Keyboard event handler for connection deletion
        function handleKeyDown(e) {
            // Handle Delete or Backspace for connection deletion
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedConnection) {
                e.preventDefault(); // Prevent default browser behavior
                

                
                // Show confirmation dialog
                const startName = selectedConnection.startNode.name;
                const endName = selectedConnection.endNode.name;
                const confirmMessage = `Are you sure you want to delete the connection from "${startName}" to "${endName}"?\n\nThis will restore the original value of "${endName}".`;
                
                if (confirm(confirmMessage)) {

                    deleteSelectedConnection();
                } else {

                }
                return;
            }
            
            // Handle Ctrl+M for mini-map toggle
            if (e.ctrlKey && e.key === 'm') {
                e.preventDefault();
                toggleMiniMap();
                return;
            }
            
            // Handle Ctrl+0 for reset zoom
            if (e.ctrlKey && e.key === '0') {
                e.preventDefault();
                resetZoom();
                return;
            }
        }

        // Delete the currently selected connection
        function deleteSelectedConnection() {
            if (!selectedConnection) return;
            
            const startName = selectedConnection.startNode.name;
            const endName = selectedConnection.endNode.name;
            

            
            // Remove the connection
            const connectionIndex = connections.findIndex(conn => 
                conn.startNode.id === selectedConnection.startNode.id && 
                conn.endNode.id === selectedConnection.endNode.id &&
                conn.startSocket === selectedConnection.startSocket && 
                conn.endSocket === selectedConnection.endSocket
            );
            
            if (connectionIndex !== -1) {
                connections.splice(connectionIndex, 1);

            }
            
            // Restore the original value of the target node
            const targetNode = selectedConnection.endNode;
            
            // Find the original token value from the tokens object
            const targetLayer = targetNode.layer;
            const targetToken = tokens[targetLayer]?.find(t => t.name === targetNode.name);
            
            if (targetToken && targetNode.originalValue) {
                // Restore the node's value to its original value
                const oldValue = targetNode.value;
                targetNode.value = targetNode.originalValue;
                
                // Also restore the corresponding token in the tokens object
                targetToken.value = targetNode.originalValue;

                
                // Update sidebar
                renderSidebar();
            } else {
                console.warn(`No original value found for node ${targetNode.name}, cannot restore`);
            }
            
            // Clear selection
            selectedConnection = null;
            
            // Save state
            saveState();
            
            // Re-render
            render();
            

        }

        // ===== SAVE/LOAD SESSION FUNCTIONS =====
        
        // Show save session modal
        function showSaveModal() {
            const modal = document.getElementById('dtmc-save-modal');
            const sessionNameInput = document.getElementById('session-name');
            const sessionDescriptionInput = document.getElementById('session-description');
            const tokenCountSpan = document.getElementById('save-token-count');
            const connectionCountSpan = document.getElementById('save-connection-count');
            const lastModifiedSpan = document.getElementById('save-last-modified');
            
            // Update session info
            const totalTokens = Object.values(tokens).flat().length;
            const totalConnections = connections.length;
            
            tokenCountSpan.textContent = totalTokens;
            connectionCountSpan.textContent = totalConnections;
            lastModifiedSpan.textContent = new Date().toLocaleString();
            
            // Clear previous inputs
            sessionNameInput.value = '';
            sessionDescriptionInput.value = '';
            
            // Reset radio buttons to "new session"
            document.querySelector('input[name="save-option"][value="new"]').checked = true;
            document.getElementById('new-session-fields').style.display = 'block';
            document.getElementById('overwrite-session-fields').style.display = 'none';
            
            // Load existing sessions for overwrite option
            loadOverwriteSessionsList();
            
            // Show modal
            modal.style.display = 'flex';
            sessionNameInput.focus();
            
            // Setup event listeners
            setupSaveModalEvents();
        }
        
        // Load overwrite sessions list
        function loadOverwriteSessionsList() {
            const sessionsList = document.getElementById('dtmc-overwrite-sessions-list');
            const sessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            
            if (Object.keys(sessions).length === 0) {
                sessionsList.innerHTML = '<div class="dtmc-session-item"><div class="dtmc-session-item-description">No saved sessions found</div></div>';
                return;
            }
            
            // Sort sessions by timestamp (newest first)
            const sortedSessions = Object.values(sessions).sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            sessionsList.innerHTML = sortedSessions.map(session => {
                const date = new Date(session.timestamp).toLocaleString();
                const nodeCount = session.data.nodes.length;
                const connectionCount = session.data.connections.length;
                
                return `
                    <div class="dtmc-session-item" data-session-name="${session.name}">
                        <div class="dtmc-session-item-header">
                            <div class="dtmc-session-item-name">${session.name}</div>
                            <div class="dtmc-session-item-date">${date}</div>
                        </div>
                        ${session.description ? `<div class="dtmc-session-item-description">${session.description}</div>` : ''}
                        <div class="dtmc-session-item-stats">
                            <div class="dtmc-session-item-stat">
                                <span>üéØ</span>
                                <span>${nodeCount} tokens</span>
                            </div>
                            <div class="dtmc-session-item-stat">
                                <span>üîó</span>
                                <span>${connectionCount} connections</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Setup save modal event listeners
        function setupSaveModalEvents() {
            const modal = document.getElementById('dtmc-save-modal');
            const sessionNameInput = document.getElementById('session-name');
            const saveBtn = document.getElementById('dtmc-save-confirm-btn');
            const cancelBtn = document.getElementById('dtmc-save-cancel-btn');
            const radioOptions = document.querySelectorAll('input[name="save-option"]');
            const newSessionFields = document.getElementById('new-session-fields');
            const overwriteSessionFields = document.getElementById('overwrite-session-fields');
            const overwriteSessionsList = document.getElementById('dtmc-overwrite-sessions-list');
            
            // Radio button change handler
            radioOptions.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    if (e.target.value === 'new') {
                        newSessionFields.style.display = 'block';
                        overwriteSessionFields.style.display = 'none';
                    } else {
                        newSessionFields.style.display = 'none';
                        overwriteSessionFields.style.display = 'block';
                    }
                });
            });
            
            // Overwrite session selection
            overwriteSessionsList.onclick = (e) => {
                const sessionItem = e.target.closest('.dtmc-session-item');
                if (!sessionItem) return;
                
                // Remove previous selection
                document.querySelectorAll('#dtmc-overwrite-sessions-list .dtmc-session-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Add selection to clicked item
                sessionItem.classList.add('selected');
            };
            
            // Save button click
            saveBtn.onclick = () => {
                const selectedOption = document.querySelector('input[name="save-option"]:checked').value;
                
                if (selectedOption === 'new') {
                    const sessionName = sessionNameInput.value.trim();
                    if (!sessionName) {
                        alert('Please enter a session name');
                        return;
                    }
                    saveSession(sessionName);
                } else {
                    const selectedSession = document.querySelector('#dtmc-overwrite-sessions-list .dtmc-session-item.selected');
                    if (!selectedSession) {
                        alert('Please select a session to overwrite');
                        return;
                    }
                    const sessionName = selectedSession.dataset.sessionName;
                    saveSession(sessionName, true);
                }
            };
            
            // Cancel button click
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Enter key in name input
            sessionNameInput.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    saveBtn.click();
                }
            };
            
            // Click outside modal to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Save session to localStorage
        function saveSession(sessionName, isOverwrite = false) {
            const sessionDescription = document.getElementById('session-description').value.trim();
            
            const sessionData = {
                name: sessionName,
                description: sessionDescription,
                timestamp: new Date().toISOString(),
                data: {
                    nodes: nodes,
                    connections: connections,
                    tokens: tokens,
                    panOffset: panOffset,
                    zoomLevel: zoomLevel
                }
            };
            
            // Get existing sessions
            const existingSessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            
            // Add new session (overwrite if name exists)
            existingSessions[sessionName] = sessionData;
            
            // Save to localStorage
            localStorage.setItem('dtmc-sessions', JSON.stringify(existingSessions));
            
            // Close modal
            document.getElementById('dtmc-save-modal').style.display = 'none';
            
            // Show success message
            const message = isOverwrite ? 
                `Session "${sessionName}" overwritten successfully!` : 
                `Session "${sessionName}" saved successfully!`;
            showNotification(message, 'success');
            

        }
        
        // Show load session modal
        function showLoadModal() {
            const modal = document.getElementById('dtmc-load-modal');
            const sessionsList = document.getElementById('dtmc-sessions-list');
            
            // Load and display sessions
            loadSessionsList();
            
            // Show modal
            modal.style.display = 'flex';
            
            // Setup event listeners
            setupLoadModalEvents();
        }
        
        // Load sessions list from localStorage
        function loadSessionsList() {
            const sessionsList = document.getElementById('dtmc-sessions-list');
            const sessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            
            if (Object.keys(sessions).length === 0) {
                sessionsList.innerHTML = '<div class="dtmc-session-item"><div class="dtmc-session-item-description">No saved sessions found</div></div>';
                return;
            }
            
            // Sort sessions by timestamp (newest first)
            const sortedSessions = Object.values(sessions).sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            sessionsList.innerHTML = sortedSessions.map(session => {
                const date = new Date(session.timestamp).toLocaleString();
                const nodeCount = session.data.nodes.length;
                const connectionCount = session.data.connections.length;
                
                return `
                    <div class="dtmc-session-item" data-session-name="${session.name}">
                        <div class="dtmc-session-item-header">
                            <div class="dtmc-session-item-name">${session.name}</div>
                            <div class="dtmc-session-item-date">${date}</div>
                        </div>
                        ${session.description ? `<div class="dtmc-session-item-description">${session.description}</div>` : ''}
                        <div class="dtmc-session-item-stats">
                            <div class="dtmc-session-item-stat">
                                <span>üéØ</span>
                                <span>${nodeCount} tokens</span>
                            </div>
                            <div class="dtmc-session-item-stat">
                                <span>üîó</span>
                                <span>${connectionCount} connections</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Setup load modal event listeners
        function setupLoadModalEvents() {
            const modal = document.getElementById('dtmc-load-modal');
            const sessionsList = document.getElementById('dtmc-sessions-list');
            const loadBtn = document.getElementById('dtmc-load-confirm-btn');
            const cancelBtn = document.getElementById('dtmc-load-cancel-btn');
            let selectedSessionName = null;
            
            // Session item click
            sessionsList.onclick = (e) => {
                const sessionItem = e.target.closest('.dtmc-session-item');
                if (!sessionItem) return;
                
                // Remove previous selection
                document.querySelectorAll('.dtmc-session-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Add selection to clicked item
                sessionItem.classList.add('selected');
                selectedSessionName = sessionItem.dataset.sessionName;
                
                // Enable load button
                loadBtn.disabled = false;
            };
            
            // Load button click
            loadBtn.onclick = () => {
                if (selectedSessionName) {
                    loadSession(selectedSessionName);
                }
            };
            
            // Cancel button click
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Click outside modal to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Load session from localStorage
        function loadSession(sessionName) {
            const sessions = JSON.parse(localStorage.getItem('dtmc-sessions') || '{}');
            const sessionData = sessions[sessionName];
            
            if (!sessionData) {
                showNotification(`Session "${sessionName}" not found!`, 'error');
                return;
            }
            
            // Confirm before loading (will replace current setup)
            const confirmMessage = `Are you sure you want to load session "${sessionName}"?\n\nThis will replace your current setup with ${sessionData.data.nodes.length} tokens and ${sessionData.data.connections.length} connections.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                // Load session data
                nodes = sessionData.data.nodes;
                connections = sessionData.data.connections;
                tokens = sessionData.data.tokens;
                groups = sessionData.data.groups || []; // Load groups if they exist
                panOffset = sessionData.data.panOffset || { x: 0, y: 0 };
                zoomLevel = sessionData.data.zoomLevel || 1.0;
                
                // Fix connection references to point to the newly loaded nodes
                connections.forEach(connection => {
                    // Find the corresponding nodes in the newly loaded nodes array
                    const startNode = nodes.find(node => node.id === connection.startNode.id);
                    const endNode = nodes.find(node => node.id === connection.endNode.id);
                    
                    if (startNode && endNode) {
                        connection.startNode = startNode;
                        connection.endNode = endNode;
                    } else {
                        console.warn('Could not find node references for connection:', connection);
                    }
                });
                
                console.log(`Fixed ${connections.length} connection references`);
                
                // Fix group node references to point to the newly loaded nodes
                if (groups && groups.length > 0) {
                    groups.forEach(group => {
                        if (group.nodes && group.nodes.length > 0) {
                            // Find the actual node objects that correspond to the group's nodes
                            const actualNodes = group.nodes.map(groupNode => {
                                // Try to find by ID first, then by name as fallback
                                return nodes.find(node => 
                                    node.id === groupNode.id || 
                                    (node.name === groupNode.name && node.layer === groupNode.layer)
                                );
                            }).filter(node => node !== undefined);
                            
                            group.nodes = actualNodes; // Use the actual node objects from the loaded nodes array
                            
                            // Recalculate group bounds
                            if (group.nodes.length > 0) {
                                group.bounds = calculateGroupBounds(group.nodes);
                                
                                // If group was collapsed, maintain collapsed state
                                if (group.isCollapsed) {
                                    const centerX = group.bounds.x + group.bounds.width / 2;
                                    const centerY = group.bounds.y + group.bounds.height / 2;
                                    const collapsedWidth = calculateMinimumGroupWidth(group);
                                    const collapsedHeight = 80;
                                    
                                    group.bounds = {
                                        x: centerX - collapsedWidth / 2,
                                        y: centerY - collapsedHeight / 2,
                                        width: collapsedWidth,
                                        height: collapsedHeight
                                    };
                                    
                                    // Update header bounds for collapsed state
                                    group.bounds.headerBounds = {
                                        x: group.bounds.x + 10,
                                        y: group.bounds.y - 15,
                                        width: group.bounds.width - 20,
                                        height: 30
                                    };
                                }
                            }
                        }
                    });
                    console.log(`Fixed ${groups.length} group node references`);
                }
                
                // Clear selections
                selectedNode = null;
                selectedConnection = null;
                
                // Create automatic connections for all nodes with references
                createAllAutomaticConnections();
                
                // Update UI
                renderSidebar();
                updateZoomDisplay();
                render();
                
                // Close modal
                document.getElementById('dtmc-load-modal').style.display = 'none';
                
                // Show success message
                showNotification(`Session "${sessionName}" loaded successfully!`, 'success');
                
                console.log(`Session "${sessionName}" loaded with ${nodes.length} nodes and ${connections.length} connections`);
                
            } catch (error) {
                console.error('Error loading session:', error);
                showNotification('Error loading session. The session data might be corrupted.', 'error');
            }
        }
        
        // Handle JSON file loading
        function handleJSONFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    loadFromJSON(jsonData, file.name);
                } catch (error) {
                    console.error('Error parsing JSON file:', error);
                    showNotification('Error parsing JSON file. Please check the file format.', 'error');
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Load complete state from JSON data
        function loadFromJSON(jsonData, fileName) {
            // Validate JSON structure
            if (!validateJSONStructure(jsonData)) {
                showNotification('Invalid JSON structure. Please ensure the file contains tokens, nodes, and connections.', 'error');
                return;
            }
            
            // Confirm before loading
            const nodeCount = jsonData.nodes ? jsonData.nodes.length : 0;
            const connectionCount = jsonData.connections ? jsonData.connections.length : 0;
            const tokenCount = jsonData.tokens ? Object.values(jsonData.tokens).flat().length : 0;
            const groupCount = jsonData.groups ? jsonData.groups.length : 0;
            
            const confirmMessage = `Load JSON file "${fileName}"?\n\nThis will replace your current setup with:\n‚Ä¢ ${tokenCount} tokens\n‚Ä¢ ${nodeCount} nodes\n‚Ä¢ ${connectionCount} connections\n‚Ä¢ ${groupCount} groups`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                // Clear current state
                clearAll();
                
                // Load tokens
                if (jsonData.tokens) {
                    tokens = {
                        primitive: jsonData.tokens.primitive || [],
                        base: jsonData.tokens.base || [],
                        semantic: jsonData.tokens.semantic || [],
                        specific: jsonData.tokens.specific || []
                    };
                }
                
                // Load token groups
                if (jsonData.tokenGroups) {
                    tokenGroups = {
                        primitive: jsonData.tokenGroups.primitive || {},
                        base: jsonData.tokenGroups.base || {},
                        semantic: jsonData.tokenGroups.semantic || {},
                        specific: jsonData.tokenGroups.specific || {}
                    };
                } else {
                    // Initialize empty token groups if not present
                    tokenGroups = {
                        primitive: {},
                        base: {},
                        semantic: {},
                        specific: {}
                    };
                }
                
                // Load nodes
                if (jsonData.nodes) {
                    nodes = jsonData.nodes.map(node => ({
                        ...node,
                        // Ensure all required properties exist
                        id: node.id || Date.now() + Math.random(),
                        x: node.x || 100,
                        y: node.y || 100,
                        name: node.name || 'unnamed',
                        value: node.value || '',
                        type: node.type || 'color',
                        layer: node.layer || 'primitive',
                        originalValue: node.originalValue || node.value || ''
                    }));
                }
                
                // Load connections
                if (jsonData.connections) {
                    connections = jsonData.connections.map(connection => {
                        // Find the actual node objects
                        const startNode = nodes.find(node => node.id === connection.startNode?.id || node.name === connection.startNode?.name);
                        const endNode = nodes.find(node => node.id === connection.endNode?.id || node.name === connection.endNode?.name);
                        
                        if (startNode && endNode) {
                            return {
                                ...connection,
                                startNode: startNode,
                                endNode: endNode
                            };
                        } else {
                            console.warn('Could not find node references for connection:', connection);
                            return null;
                        }
                    }).filter(conn => conn !== null);
                }
                
                // Load groups if they exist
                if (jsonData.groups) {
                    groups = jsonData.groups.map(group => {
                        // Find the actual node objects that correspond to the group's nodes
                        const actualNodes = (group.nodes || []).map(groupNode => {
                            // Try to find by ID first, then by name as fallback
                            return nodes.find(node => 
                                node.id === groupNode.id || 
                                (node.name === groupNode.name && node.layer === groupNode.layer)
                            );
                        }).filter(node => node !== undefined);
                        
                        return {
                            ...group,
                            // Ensure all required properties exist
                            id: group.id || Date.now() + Math.random(),
                            name: group.name || 'Unnamed Group',
                            nodes: actualNodes, // Use the actual node objects from the loaded nodes array
                            isCollapsed: group.isCollapsed || false,
                            originalBounds: group.originalBounds || null,
                            headerBounds: group.headerBounds || null
                        };
                    });
                    
                    // Recalculate group bounds for all loaded groups
                    groups.forEach(group => {
                        if (group.nodes.length > 0) {
                            group.bounds = calculateGroupBounds(group.nodes);
                            
                            // If group was collapsed, maintain collapsed state
                            if (group.isCollapsed) {
                                const centerX = group.bounds.x + group.bounds.width / 2;
                                const centerY = group.bounds.y + group.bounds.height / 2;
                                const collapsedWidth = calculateMinimumGroupWidth(group);
                                const collapsedHeight = 80;
                                
                                group.bounds = {
                                    x: centerX - collapsedWidth / 2,
                                    y: centerY - collapsedHeight / 2,
                                    width: collapsedWidth,
                                    height: collapsedHeight
                                };
                                
                                // Update header bounds for collapsed state
                                group.bounds.headerBounds = {
                                    x: group.bounds.x + 10,
                                    y: group.bounds.y - 15,
                                    width: group.bounds.width - 20,
                                    height: 30
                                };
                            }
                        }
                    });
                }
                
                // Load canvas state
                if (jsonData.panOffset) {
                    panOffset = jsonData.panOffset;
                }
                if (jsonData.zoomLevel) {
                    zoomLevel = jsonData.zoomLevel;
                }
                
                // Load UI state
                if (jsonData.selectedLayer) {
                    selectedLayer = jsonData.selectedLayer;
                }
                if (jsonData.selectedTokenType) {
                    selectedTokenType = jsonData.selectedTokenType;
                }
                
                // Restore selected nodes
                if (jsonData.selectedNodes && Array.isArray(jsonData.selectedNodes)) {
                    selectedNodes = jsonData.selectedNodes.map(nodeId => 
                        nodes.find(node => node.id === nodeId)
                    ).filter(node => node !== undefined);
                    selectedNode = selectedNodes.length > 0 ? selectedNodes[0] : null;
                } else {
                    selectedNodes = [];
                    selectedNode = null;
                }
                
                // Clear other selections
                selectedConnection = null;
                hoveredConnection = null;
                
                // Create automatic connections for all nodes with references
                createAllAutomaticConnections();
                
                // Update UI
                renderSidebar();
                updateZoomDisplay();
                render();
                
                // Show success message
                showNotification(`JSON file "${fileName}" loaded successfully!`, 'success');
                
                console.log(`JSON file loaded: ${tokenCount} tokens, ${nodeCount} nodes, ${connectionCount} connections, ${groupCount} groups`);
                
            } catch (error) {
                console.error('Error loading JSON file:', error);
                showNotification('Error loading JSON file. The file might be corrupted.', 'error');
            }
        }
        
        // Validate JSON structure
        function validateJSONStructure(jsonData) {
            if (!jsonData || typeof jsonData !== 'object') {
                return false;
            }
            
            // Check for required structure
            const hasTokens = jsonData.tokens && typeof jsonData.tokens === 'object';
            const hasNodes = jsonData.nodes && Array.isArray(jsonData.nodes);
            const hasConnections = jsonData.connections && Array.isArray(jsonData.connections);
            const hasGroups = jsonData.groups && Array.isArray(jsonData.groups);
            
            // At least one of these should be present
            return hasTokens || hasNodes || hasConnections || hasGroups;
        }
        
        // Show notification message
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `dtmc-notification dtmc-notification-${type}`;
            notification.textContent = message;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Show notification
            setTimeout(() => {
                notification.classList.add('dtmc-notification-show');
            }, 100);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.remove('dtmc-notification-show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        // Initialize when page loads
        window.onload = init;
        

    </script>
</body>
</html>


